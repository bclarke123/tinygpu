!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("tinygpu",[],t):"object"==typeof exports?exports.tinygpu=t():e.tinygpu=t()}(self,(()=>(()=>{"use strict";var e={35:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Material=void 0,t.Material=class{constructor(e){this._uniformManager=e}get bindGroupLayout(){var e;return null===(e=this._uniformManager)||void 0===e?void 0:e.bindGroupLayout}get bindGroup(){var e;return null===(e=this._uniformManager)||void 0===e?void 0:e.bindGroup}updateUniform(e){this._uniformManager.updateUniform(e)}update(){var e;null===(e=this._uniformManager)||void 0===e||e.update()}}},41:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Scene=void 0;const i=n(541),r=n(717),o=n(343);class a extends i.Transform{constructor(e){super(),this._uniformManager=new o.UniformManager(e,{uniforms:[{name:"projection matrix",value:r.mat4.create()},{name:"view matrix",value:r.mat4.create()},{name:"camera position",value:r.vec3.create()},{name:"resolution",value:r.vec2.create(1,1)},{name:"time",value:performance.now()/1e3}]})}update(e,t){this._uniformManager.updateUniform({name:"projection matrix",value:e.projectionMatrix}),this._uniformManager.updateUniform({name:"view matrix",value:e.viewMatrix}),this._uniformManager.updateUniform({name:"camera position",value:e.position}),this._uniformManager.updateUniform({name:"resolution",value:t}),this._uniformManager.updateUniform({name:"time",value:performance.now()/1e3}),this._uniformManager.update()}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}}t.Scene=a},43:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="struct Uniforms {\n  color: vec4<f32>\n}\n\n@group(BG_UNIFORMS) @binding(0) var<uniform> uniforms: Uniforms;\n@group(BG_UNIFORMS) @binding(1) var tex_sampler: sampler;\n@group(BG_UNIFORMS) @binding(2) var tex_map: texture_2d<f32>;\n\nstruct VSOut {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs_main(in: VSIn) -> VSOut {\n  let modelViewProj: mat4x4<f32> = scene_uniforms.projection * scene_uniforms.view * model_uniforms.model;\n\n  let vs_out: VSOut = VSOut(\n    modelViewProj * vec4<f32>(in.position, 1.0),\n    in.uv,\n  );\n  return vs_out;\n}\n\n@fragment\nfn fs_main(vs_out: VSOut) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(tex_map, tex_sampler, vs_out.uv);\n  return color * uniforms.color;\n}\n"},80:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Geometry=void 0,t.Geometry=class{constructor(e,t,n,i,r){this._renderer=e,this._vertexBuffer=t,this._indexBuffer=n,this._indexCount=i,this._vertexCount=r}get device(){return this._renderer.device}get vertexBuffer(){return this._vertexBuffer}get indexBuffer(){return this._indexBuffer}get indexCount(){return this._indexCount}get vertexCount(){return this._vertexCount}get uvBuffer(){return this._uvBuffer}}},108:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Mesh=void 0;const i=n(541),r=n(343);class o extends i.Transform{constructor(e,t,n,i=1,o){super(),this._device=e,this.material=t,this.geometry=n,this._instances=i,this._uniformManager=new r.UniformManager(e,{uniforms:[{name:"model",value:this.worldMatrix}],buffers:o||[],label:"Mesh"})}get cacheKey(){return`${this.geometry.cacheKey}-${this.material.cacheKey}-${this._uniformManager.cacheKey}`}update(){this.material.update(),this._uniformManager.updateUniform({name:"model",value:this.worldMatrix}),this._uniformManager.update()}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}get bufferLayout(){return this.geometry.bufferLayout}get buffers(){return this._uniformManager.buffers}get instanceCount(){return this._instances}}t.Mesh=o},149:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OrthographicCamera=t.PerspectiveCamera=t.Camera=void 0;var i=n(534);Object.defineProperty(t,"Camera",{enumerable:!0,get:function(){return i.Camera}});var r=n(599);Object.defineProperty(t,"PerspectiveCamera",{enumerable:!0,get:function(){return r.PerspectiveCamera}});var o=n(779);Object.defineProperty(t,"OrthographicCamera",{enumerable:!0,get:function(){return o.OrthographicCamera}})},161:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CubeGeometry=void 0;const i=n(80);class r extends i.Geometry{constructor(e){const{vertices:t,indices:n,vertexCount:i,indexCount:r,arrayStride:o}=function(){const e=[[-.5,-.5,.5,0,1,0,0,1],[.5,-.5,.5,1,1,0,0,1],[.5,.5,.5,1,0,0,0,1],[-.5,.5,.5,0,0,0,0,1],[.5,-.5,-.5,1,1,0,0,-1],[-.5,-.5,-.5,0,1,0,0,-1],[-.5,.5,-.5,0,0,0,0,-1],[.5,.5,-.5,1,0,0,0,-1],[.5,-.5,.5,0,1,1,0,0],[.5,-.5,-.5,1,1,1,0,0],[.5,.5,-.5,1,0,1,0,0],[.5,.5,.5,0,0,1,0,0],[-.5,-.5,-.5,1,1,-1,0,0],[-.5,-.5,.5,0,1,-1,0,0],[-.5,.5,.5,0,0,-1,0,0],[-.5,.5,-.5,1,0,-1,0,0],[-.5,.5,.5,0,1,0,1,0],[.5,.5,.5,1,1,0,1,0],[.5,.5,-.5,1,0,0,1,0],[-.5,.5,-.5,0,0,0,1,0],[-.5,-.5,-.5,0,1,0,-1,0],[.5,-.5,-.5,1,1,0,-1,0],[.5,-.5,.5,1,0,0,-1,0],[-.5,-.5,.5,0,0,0,-1,0]],t=[];e.forEach((e=>t.push(...e)));const n=new Float32Array(t),i=e.length,r=[];for(let e=0;e<6;e++){const t=4*e;r.push(t+0,t+1,t+2,t+0,t+2,t+3)}const o=new Uint16Array(r);return{vertices:n,indices:o,vertexCount:i,indexCount:o.length,arrayStride:32,floatsPerVertex:8}}(),a=e.createBuffer(t,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),s=e.createBuffer(n,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST);super(e,a,s,r,i),this._arrayStride=o}get cacheKey(){return"CubeGeometry"}get bufferLayout(){return[{arrayStride:this._arrayStride,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]}}t.CubeGeometry=r},192:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="struct VSOut {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs_main(in: VSIn) -> VSOut {\n  let modelViewProj: mat4x4<f32> = scene_uniforms.projection * scene_uniforms.view * model_uniforms.model;\n\n  let vs_out: VSOut = VSOut(\n    modelViewProj * vec4<f32>(in.position, 1.0),\n    in.uv,\n  );\n  return vs_out;\n}\n\n@fragment\nfn fs_main(vs_out: VSOut) -> @location(0) vec4<f32> {\n  return vec4(vs_out.uv, 0.0, 1.0);\n}\n"},249:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.packUniforms=function(e,t,n=0){let i=0,r=0;const o=[];if(0===e.length)return t||new ArrayBuffer(0);for(const t of e){const e=s(t);r=Math.max(r,e.align),i+=(e.align-i%e.align)%e.align,o.push(Object.assign(Object.assign({},e),{relativeOffset:i,itemData:t})),i+=e.advanceAmount}const a=i+(r-i%r)%r;let u,c;if(t){if(t.byteLength<n+a)throw new Error(`Target buffer too small. Need ${a} at offset ${n}, but buffer has ${t.byteLength} bytes.`);u=t,c=n}else u=new ArrayBuffer(a),c=0;const l=new DataView(u),f=new Float32Array(u);function d(e,t,n){if(t.isStruct){if("object"!=typeof e||null===e||Array.isArray(e))throw new Error(`Expected an object for struct value "${t.typeName}", but got ${typeof e}`);const i=e;for(const e in t.membersLayout){const r=t.membersLayout[e],o=i[e];if(void 0===o)throw new Error(`Value for struct member "${e}" of struct "${t.typeName}" not provided.`);d(o,r,n+r.relativeOffset)}}else switch(t.typeName){case"u32":l.setUint32(n,e,!0);break;case"f32":l.setFloat32(n,e,!0);break;case"color":f.set(e.uniformValue(),n/4);break;case"vec2":case"vec4":case"vec3":case"mat4":f.set(e,n/4);break;case"mat3":const i=e,r=t.paddedStride/4;for(let e=0;e<3;++e){const t=3*e,o=n/4+e*r;f.set(i.subarray(t,t+3),o)}break;default:throw new Error(`Unsupported typeName for writing: "${t.typeName}" at offset ${n}`)}}for(const e of o)d(e.itemData.value,e,c+e.relativeOffset);return u},t.uploadUniformBuffer=function(e,t,n="Uniform Buffer",i){return null!=i||(i=t.createBuffer({label:n,size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM})),t.queue.writeBuffer(i,0,e,0,e.byteLength),i};const i=n(710),r={f32:{typeName:"f32",align:4,size:4,advanceAmount:4},i32:{typeName:"i32",align:4,size:4,advanceAmount:4},u32:{typeName:"u32",align:4,size:4,advanceAmount:4},vec2:{typeName:"vec2",align:8,size:8,advanceAmount:8},vec3:{typeName:"vec3",align:16,size:12,advanceAmount:16},vec4:{typeName:"vec4",align:16,size:16,advanceAmount:16},color:{typeName:"color",align:16,size:16,advanceAmount:16},mat3:{typeName:"mat3",align:16,size:36,advanceAmount:48,paddedStride:16},mat4:{typeName:"mat4",align:16,size:64,advanceAmount:64,paddedStride:16}},o={};function a(e,t){if("number"==typeof e)return Number.isInteger(e)?"u32":"f32";if(e instanceof i.Color)return"color";if(e instanceof Float32Array)switch(e.length){case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";case 9:case 12:return"mat3";case 16:return"mat4";default:throw new Error(`Unsupported Float32Array length for item "${t}" for type inference: ${e.length}`)}throw new Error(`Cannot infer base type for item "${t}". Value type: ${typeof e}. If it's a struct, its 'type' (and 'members' if new) must be defined.`)}function s(e){let t=e.type;const n=e.members,i=e.name;if(n){if(!t)throw new Error(`Struct item "${i}" must have a 'type' property defining its name when 'members' are provided.`);if(o[t])return o[t];let r=0,u=0;const c={},l=e.value;if("object"!=typeof e.value||null===e.value||Array.isArray(e.value))throw new Error(`Value for struct "${i}" must be an object when 'members' are defined for layout calculation.`);for(const e of n){const n=e.name,o=l[n];if(void 0===o&&!e.type&&!e.members)throw new Error(`Value for struct member "${n}" of struct "${t}" not provided, and type cannot be inferred.`);let f=e.type;if(f||e.members){if(!f&&e.members)throw new Error(`Inline nested struct member "${n}" within "${t}" must have its own 'type' (name) defined.`)}else{if(void 0===o)throw new Error(`Value for struct member "${n}" needed for type inference.`);f=a(o,`${i}.${n}`)}const d=s({name:n,value:o,type:f,members:e.members});u=Math.max(u,d.align);const h=d.align;r+=(h-r%h)%h,c[n]=Object.assign(Object.assign({},d),{relativeOffset:r}),r+=d.advanceAmount}const f=r+(u-r%u)%u,d={align:u,size:f,advanceAmount:f,isStruct:!0,membersLayout:c,typeName:t};return o[t]=d,d}if(t){if(r[t])return r[t];if(o[t])return o[t];throw new Error(`Unknown explicit type "${t}" for item "${i}" and not a defined struct in cache.`)}{const t=a(e.value,i);if(r[t])return r[t];throw new Error(`Could not get layout for inferred type "${t}" for item "${i}".`)}}},325:function(e,t,n){var i,r=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,i,r)}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||(i=function(e){return i=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},i(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=i(e),a=0;a<n.length;a++)"default"!==n[a]&&r(t,e,n[a]);return o(t,e),t});Object.defineProperty(t,"__esModule",{value:!0}),t.fluid=t.compute=t.material=t.geometry=t.camera=t.Transform=t.Scene=t.ImageTexture=t.DefaultTexture=t.Color=t.Renderer=void 0;var s=n(366);Object.defineProperty(t,"Renderer",{enumerable:!0,get:function(){return s.Renderer}});var u=n(710);Object.defineProperty(t,"Color",{enumerable:!0,get:function(){return u.Color}});var c=n(330);Object.defineProperty(t,"DefaultTexture",{enumerable:!0,get:function(){return c.DefaultTexture}}),Object.defineProperty(t,"ImageTexture",{enumerable:!0,get:function(){return c.ImageTexture}});var l=n(41);Object.defineProperty(t,"Scene",{enumerable:!0,get:function(){return l.Scene}});var f=n(541);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return f.Transform}}),t.camera=a(n(149)),t.geometry=a(n(722)),t.material=a(n(760)),t.compute=a(n(898)),t.fluid=a(n(482))},330:function(e,t){var n=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,o){function a(e){try{u(i.next(e))}catch(e){o(e)}}function s(e){try{u(i.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.ImageTexture=t.DefaultTexture=t.MappedTexture=t.Texture=void 0;class i{constructor(){}}t.Texture=i,t.MappedTexture=class extends i{constructor(e){super(),this._descriptor=e}get descriptor(){return this._descriptor}get view(){return this._view||(this._view=this._texture.createView()),this._view}upload(e){this._texture=e.createTexture(this.descriptor)}dispose(){this._texture.destroy()}get width(){return this._texture.width}get height(){return this._texture.height}get label(){return this._texture.label}get format(){return this._texture.format}get dimension(){return this._texture.dimension}};class r extends i{constructor(){super(),this._texture=null,this._textureView=null,this._pixelData=new Uint8Array([255,255,255,255])}get width(){return 1}get height(){return 1}get descriptor(){return{size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,dimension:"2d",mipLevelCount:1,sampleCount:1}}get view(){var e;if(!this._texture)throw new Error("Texture not created");return null!==(e=this._textureView)&&void 0!==e||(this._textureView=this._texture.createView()),this._textureView}get label(){return"Default Texture"}get format(){return this._texture.format}get dimension(){return this._texture.dimension}upload(e){this._texture||(this._texture=e.createTexture(this.descriptor),e.queue.writeTexture({texture:this._texture,mipLevel:0,origin:{x:0,y:0,z:0}},this._pixelData,{offset:0,bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1}))}dispose(){var e;null===(e=this._texture)||void 0===e||e.destroy(),this._texture=null,this._textureView=null}}t.DefaultTexture=r,r.instance=new r,t.ImageTexture=class extends i{constructor(e){super(),this._width=0,this._height=0,this._texture=null,this._textureView=null,this._imagedata=null,this.src=e}load(){return n(this,void 0,void 0,(function*(){const e=yield fetch(this.src);if(!e.ok)throw new Error(`Failed to load image: ${this.src}`);const t=yield e.blob(),n=yield createImageBitmap(t);this._imagedata=n,this._width=n.width,this._height=n.height}))}get width(){return this._width}get height(){return this._height}get descriptor(){return{size:{width:this._width,height:this._height,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:1,sampleCount:1}}get view(){var e;if(!this._texture)throw new Error("Texture not created");return null!==(e=this._textureView)&&void 0!==e||(this._textureView=this._texture.createView()),this._textureView}get label(){return`ImageTexture ${this.src}`}get format(){return this._texture.format}get dimension(){return this._texture.dimension}upload(e){if(!this._texture){if(!this._imagedata)throw new Error("Image not loaded");this._texture=e.createTexture(this.descriptor),e.queue.copyExternalImageToTexture({source:this._imagedata,origin:{x:0,y:0},flipY:!0},{texture:this._texture,origin:{x:0,y:0}},{width:this._width,height:this._height,depthOrArrayLayers:1})}}dispose(){var e,t;null===(e=this._imagedata)||void 0===e||e.close(),null===(t=this._texture)||void 0===t||t.destroy(),this._texture=null,this._textureView=null,this._imagedata=null,this._width=0,this._height=0}}},331:function(e,t,n){var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.UVMaterial=void 0;const r=n(35),o=i(n(414)),a=i(n(192));class s extends r.Material{constructor(e){super(),s.precompile(e)}get cacheKey(){return"UVMaterial"}get shaderCode(){return s.shaderModule}static precompile(e){s.shaderModule||(s.shaderModule=e.createShaderModule({label:"basic-material-shader",code:`\n${o.default}\n${a.default}\n`}))}}t.UVMaterial=s,s.shaderModule=null},343:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformManager=void 0;const i=n(249);t.UniformManager=class{constructor(e,t){this._uniformsDirty=!0,this._texturesDirty=!0,this._buffersDirty=!0,this.uniformVisibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._device=e;const{uniforms:n,textures:i,buffers:r,samplers:o,label:a,uniformVisibility:s}=t;this._uniforms=n,this._textures=i,this._buffers=r,this._samplers=o,this._label=a,this._uniformsDirty=!0,this._texturesDirty=!0,s&&(this.uniformVisibility=s),(this._samplers||[]).length<1&&(this._textures||[]).length>0&&(this._samplers=[{sampler:this._device.createSampler({magFilter:"linear",minFilter:"linear"}),type:"filtering"}])}get cacheKey(){if(this._cacheKey)return this._cacheKey;const e=[this._label];for(const t of this._uniforms||[])e.push(t.name);for(const t of this._textures||[])e.push(t.texture.label);for(const t of this._buffers||[])e.push(t.buffer.label);for(const t of this._samplers||[])e.push(t.sampler.label);return this._cacheKey=e.join(":"),this._cacheKey}updateUniform(e){var t;(null===(t=this._uniforms)||void 0===t?void 0:t.find((t=>t.name===e.name))).value=e.value,this.setUniformsDirty()}updateUniforms(e){this._uniforms=e,this.setUniformsDirty()}updateTextures(e){this._textures=e,this.setTexturesDirty()}updateBuffers(e){this._buffers=e,this.setBuffersDirty()}update(){this._uniformsDirty&&(this._uniformArr=(0,i.packUniforms)(this._uniforms||[],this._uniformArr),this._uniformBuffer=(0,i.uploadUniformBuffer)(this._uniformArr,this._device,this._label,this._uniformBuffer),this._uniformsDirty=!1),this._texturesDirty&&((this._textures||[]).forEach((e=>e.texture.upload(this._device))),this._texturesDirty=!1),this._buffersDirty&&(this._bindGroup=void 0,this._bindGroupLayout=void 0)}setTexturesDirty(){this._texturesDirty=!0}setUniformsDirty(){this._uniformsDirty=!0}setBuffersDirty(){this._buffersDirty=!0}setDirty(){this.setTexturesDirty(),this.setUniformsDirty()}get buffers(){return this._buffers}get bindGroupLayoutDescriptor(){const e=[];let t=0;const{_uniforms:n,_textures:i,_samplers:r,_buffers:o}=this;if((null==n?void 0:n.length)>0&&(e.push({binding:0,visibility:this.uniformVisibility,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:0}}),t++),(null==r?void 0:r.length)>0){const n=GPUShaderStage.FRAGMENT;for(let i=0;i<r.length;i++)e.push({binding:t,visibility:r[i].visibility||n,sampler:{type:r[i].type}}),t++}if((null==i?void 0:i.length)>0){const n=GPUShaderStage.FRAGMENT;for(let r=0;r<(null==i?void 0:i.length);r++){const o=i[r],a=o.dimension||o.texture.dimension;if("sample"===o.accessType)e.push({binding:t,visibility:o.visibility||n,texture:{sampleType:"float",viewDimension:a,multisampled:!1}});else{const i=o.accessType,r=o.format||o.texture.format;e.push({binding:t,visibility:o.visibility||n,storageTexture:{access:i,format:r,viewDimension:a}})}t++}}if((null==o?void 0:o.length)>0)for(let n=0;n<(null==o?void 0:o.length);n++)e.push({binding:t,visibility:o[n].visibility,buffer:{type:o[n].type}}),t++;return{label:`${this._label} BindGroup Layout`,entries:e}}get bindGroupLayout(){return this._bindGroupLayout||(this._bindGroupLayout=this._device.createBindGroupLayout(this.bindGroupLayoutDescriptor)),this._bindGroupLayout}get bindGroupDescriptor(){let e=0;const{_uniforms:t,_textures:n,_samplers:i,_buffers:r}=this,o=[];if((null==t?void 0:t.length)>0&&(o.push({binding:e,resource:{buffer:this._uniformBuffer}}),e++),(null==i?void 0:i.length)>0)for(let t=0;t<i.length;t++)o.push({binding:e,resource:i[t].sampler}),e++;if((null==n?void 0:n.length)>0)for(let t=0;t<(null==n?void 0:n.length);t++)o.push({binding:t+e,resource:n[t].texture.view});if((null==r?void 0:r.length)>0)for(let t=0;t<(null==r?void 0:r.length);t++)o.push({binding:e,resource:{buffer:r[t].buffer}}),e++;return{label:`${this._label} BindGroup`,layout:this.bindGroupLayout,entries:o}}get bindGroup(){return this._bindGroup||(this._bindGroup=this._device.createBindGroup(this.bindGroupDescriptor)),this._bindGroup}}},366:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,o){function a(e){try{u(i.next(e))}catch(e){o(e)}}function s(e){try{u(i.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((i=i.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.Renderer=void 0;const r=n(717),o=n(779),a=n(599),s=n(108),u=n(41),c=n(898),l=n(330);t.Renderer=class{constructor(e={}){var t;this.adapter=null,this.depthFormat="depth24plus-stencil8",this.format="bgra8unorm",this.canvasSize=r.vec2.create(1,1),this.sizeDirty=!0,this._pipelineCache=new Map,this._computePipelineCache=new Map,null!==(t=this.canvas)&&void 0!==t||(this.canvas=e.canvas),console.log("Renderer initialized")}init(){return i(this,void 0,void 0,(function*(){if(!navigator.gpu)throw new Error("WebGPU is not supported in this browser");if(this.adapter=yield navigator.gpu.requestAdapter(),!this.adapter)throw new Error("No GPU adapter found");this.device=yield this.adapter.requestDevice(),console.log("GPU device initialized"),this.canvas&&this.initCanvas(this.canvas)}))}initCanvas(e){var t;if(this.canvas=e,this.context=null===(t=this.canvas)||void 0===t?void 0:t.getContext("webgpu"),!this.context)throw new Error("Failed to get WebGPU context");this.format=navigator.gpu.getPreferredCanvasFormat(),this.context.configure({device:this.device,format:this.format,alphaMode:"premultiplied"});const n=()=>{var e;const t=this.canvas.offsetWidth,n=this.canvas.offsetHeight;t===this.canvasSize[0]&&n===this.canvasSize[1]||(this.canvas.width=t,this.canvas.height=n,this.canvasSize.set([t,n]),this.sizeDirty=!0,null===(e=this.depthTexture)||void 0===e||e.destroy(),this.depthTexture=this.device.createTexture({label:"Depth texture",size:{width:t,height:n},format:this.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.depthTextureView=this.depthTexture.createView({label:"Depth texture view "}))};this.resizeObserver=new ResizeObserver(n),this.resizeObserver.observe(this.canvas),n(),console.log("Canvas initialized")}createShaderModule(e){return this.device.createShaderModule(e)}createBuffer(e,t){const n=this.device.createBuffer({size:e.byteLength+3&-4,usage:t,mappedAtCreation:!0});return e instanceof Float32Array?new Float32Array(n.getMappedRange()).set(e):e instanceof Uint32Array?new Uint32Array(n.getMappedRange()).set(e):e instanceof Uint16Array?new Uint16Array(n.getMappedRange()).set(e):e instanceof Uint8Array&&new Uint8Array(n.getMappedRange()).set(e),n.unmap(),n}createSizedBuffer(e,t){return this.device.createBuffer({size:e,usage:t})}pipelineFor(e,t){const n=t.cacheKey;if(this._pipelineCache.has(n))return this._pipelineCache.get(n);const i=t.material.shaderCode,r=t.bufferLayout,o=this.device.createPipelineLayout({label:"Pipeline Layout",bindGroupLayouts:[e.bindGroupLayout,t.bindGroupLayout,t.material.bindGroupLayout]}),a=this.device.createRenderPipeline({layout:o,vertex:{module:i,buffers:r},fragment:{module:i,targets:[{format:this.format}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,frontFace:"ccw",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}});return this._pipelineCache.set(n,a),a}render(e,t){const[n,i]=this.canvasSize,r={label:"Render pass",colorAttachments:[{view:this.context.getCurrentTexture().createView({label:"Canvas output texture view"}),clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"clear",stencilStoreOp:"store"}},o=this.device.createCommandEncoder(),a=o.beginRenderPass(r);a.setViewport(0,0,n,i,0,1),a.setScissorRect(0,0,n,i),this.sizeDirty&&(t.viewportResized(this.canvasSize),this.sizeDirty=!1),e.update(t,this.canvasSize);const u=e.bindGroup;a.setBindGroup(0,u),e.traverse((t=>{if(t instanceof s.Mesh){const n=t;n.update();const i=this.pipelineFor(e,n);a.setPipeline(i),a.setBindGroup(1,n.bindGroup),a.setBindGroup(2,n.material.bindGroup),a.setVertexBuffer(0,n.geometry.vertexBuffer),a.setIndexBuffer(n.geometry.indexBuffer,"uint16"),a.drawIndexed(n.geometry.indexCount,n.instanceCount)}})),a.end(),this.device.queue.submit([o.finish()])}computePipelineFor(e){if(!this._computePipelineCache[e.cacheKey]){const t=e.bindGroupLayout,n=this.device.createPipelineLayout({label:`${e.label} Pipeline Layout`,bindGroupLayouts:[t]}),i=this.device.createComputePipeline({layout:n,compute:{entryPoint:e.entryPoint,module:e.shaderModule}});this._computePipelineCache[e.cacheKey]=i}return this._computePipelineCache[e.cacheKey]}compute(e){const t=this.device.createCommandEncoder(),n=t.beginComputePass();for(const t of e){const e=this.computePipelineFor(t),i=t.dispatchCount,r=t.bindGroup;n.setPipeline(e),n.setBindGroup(0,r),n.dispatchWorkgroups(i[0],i[1],i[2])}n.end(),this.device.queue.submit([t.finish()])}createMaterial(e,t){return new e(this.device,t)}createGeometry(e){return new e(this)}createMesh(e,t,n,i){return new s.Mesh(this.device,t,e,n,i)}createScene(){return new u.Scene(this.device)}createPerspectiveCamera(e){return new a.PerspectiveCamera(e)}createOrthographicCamera(e){return new o.OrthographicCamera(e)}loadImageTexture(e){return i(this,void 0,void 0,(function*(){const t=new l.ImageTexture(e);return yield t.load(),t.upload(this.device),t}))}createTexture(e){const t=new l.MappedTexture(e);return t.upload(this.device),t}createSampler(e){return this.device.createSampler(e)}createComputeTask(e){return new c.ComputeTask(this.device,e)}}},386:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="//--------------------------------------------------------------------------------------\n// Structures\n//--------------------------------------------------------------------------------------\nstruct SimParams {\n    dt: f32,\n    dx: f32,\n    inv_dx: f32,\n    grid_size: u32,\n    dimensions: u32,\n    num_particles: u32,\n\n    particle_initial_volume: f32,\n    particle_mass_param: f32,\n    gravity: f32,\n\n    mu_0: f32,\n    lambda_0: f32,\n    fluid_stiffness_Ef: f32,\n\n    snow_plasticity_h_factor: f32,\n    snow_yield_min: f32,\n    snow_yield_max: f32,\n\n    boundary_extent: u32,\n};\n\nstruct Particle {\n    position: vec3<f32>,\n    velocity: vec3<f32>,\n    affine_matrix_C: mat3x3<f32>,\n    deformation_gradient_F: mat3x3<f32>,\n    mass: f32,\n    Jp: f32,\n    Jf: f32,\n    material_idx: u32,\n};\n\nconst FIXED_POINT_MULTIPLIER: f32 = 10000.0; // Define your multiplier\nconst FIXED_POINT_MULTIPLIER_INV: f32 = 1.0 / FIXED_POINT_MULTIPLIER;\nconst DIMENSIONS = 3u;\n\nfn encodeFixedPoint(val: f32) -> i32 {\n    return i32(val * FIXED_POINT_MULTIPLIER);\n}\n\nfn decodeFixedPoint(fixed_val: i32) -> f32 {\n    return f32(fixed_val) * FIXED_POINT_MULTIPLIER_INV;\n}\n\nfn grid_idx_flat_clamp(cell_coords_abs: vec3<i32>, n_grid: u32) -> u32 {\n    // Ensure positive before casting for safety if cell_coords_abs can be negative\n    // However, for reading, we expect them to be valid after boundary checks if any.\n    // For G2P, particle can be near boundary, so stencil nodes can be out of bounds.\n    let x = u32(clamp(cell_coords_abs.x, 0, i32(n_grid - 1u)));\n    let y = u32(clamp(cell_coords_abs.y, 0, i32(n_grid - 1u)));\n    let z = u32(clamp(cell_coords_abs.z, 0, i32(n_grid - 1u)));\n    return x * n_grid * n_grid + y * n_grid + z;\n}\n\nfn grid_idx_flat(cell_coords_abs: vec3<i32>, n_grid: u32) -> u32 {\n    return u32(cell_coords_abs.x) * n_grid * n_grid +\n           u32(cell_coords_abs.y) * n_grid +\n           u32(cell_coords_abs.z);\n}\n\n// Helper to convert 1D flat grid index to 3D integer grid coordinates\nfn flat_idx_to_3d_coords(flat_idx: u32, n_grid: u32) -> vec3<i32> {\n    let z = i32(flat_idx / (n_grid * n_grid));\n    let remainder = flat_idx % (n_grid * n_grid);\n    let y = i32(remainder / n_grid);\n    let x = i32(remainder % n_grid);\n    return vec3<i32>(x, y, z);\n}\n\n// Helper for APIC B-Spline\n// u is distance from particle to grid node center, in units of cell sizes\nfn quadratic_bspline_N(u : f32) -> f32 {\n    let abs_u = abs(u);\n    var N_u = 0.0;\n    if (abs_u < 0.5) {\n        N_u = 0.75 - abs_u * abs_u;\n    } else if (abs_u < 1.5) {\n        N_u = 0.5 * (1.5 - abs_u) * (1.5 - abs_u);\n    }\n    return N_u;\n}\n"},414:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="const BG_SCENE: u32 = 0;\nconst BG_MODEL: u32 = 1;\nconst BG_UNIFORMS: u32 = 2;\n\nstruct SceneUniforms {\n  projection: mat4x4<f32>,\n  view: mat4x4<f32>,\n  camera_position: vec3<f32>,\n  resolution: vec2<f32>,\n  time: f32,\n}\n\nstruct ModelUniforms {\n  model: mat4x4<f32>,\n}\n\nstruct VSIn {\n  @location(0) position: vec3f,\n  @location(1) uv: vec2f,\n  @location(2) normal: vec3f,\n}\n\n@group(BG_SCENE) @binding(0) var<uniform> scene_uniforms: SceneUniforms;\n@group(BG_MODEL) @binding(0) var<uniform> model_uniforms: ModelUniforms;\n"},482:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,o){function a(e){try{u(i.next(e))}catch(e){o(e)}}function s(e){try{u(i.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((i=i.apply(e,t||[])).next())}))},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.FluidSimulation=t.FluidSimulationOptions=void 0;const o=n(717),a=r(n(386)),s=r(n(819)),u=r(n(950)),c=r(n(861)),l=n(249);class f{constructor(e,t){this.particles=e,this.gridSize=t,this.dimensions=3,this.dt=1e-4,this.dx=1/this.gridSize,this.invDx=this.gridSize,this.particleInitialVolume=Math.pow(1/this.gridSize*.5,this.dimensions),this.particleMass=1,this.gravity=9.8,this.mu0=5e3/2.4,this.lambda0=1e3/.72,this.fluidStiffnessEf=400,this.snowPlasticityHFactor=10,this.snowYieldMin=.975,this.snowYieldMax=1.0044,this.boundaryExtent=3}asUniformItems(){return[{name:"dt",value:this.dt,type:"f32"},{name:"dx",value:this.dx,type:"f32"},{name:"inv_dx",value:this.invDx,type:"f32"},{name:"grid_size",value:this.gridSize,type:"u32"},{name:"dimensions",value:this.dimensions,type:"u32"},{name:"num_particles",value:this.particles,type:"u32"},{name:"particle_initial_volume",value:this.particleInitialVolume,type:"f32"},{name:"particle_mass_param",value:this.particleMass,type:"f32"},{name:"gravity",value:this.gravity,type:"f32"},{name:"mu_0",value:this.mu0,type:"f32"},{name:"lambda_0",value:this.lambda0,type:"f32"},{name:"fluid_stiffness_Ef",value:this.fluidStiffnessEf,type:"f32"},{name:"snow_plasticity_h_factor",value:this.snowPlasticityHFactor,type:"f32"},{name:"snow_yield_min",value:this.snowYieldMin,type:"f32"},{name:"snow_yield_max",value:this.snowYieldMax,type:"f32"},{name:"boundary_extent",value:this.boundaryExtent,type:"u32"}]}}t.FluidSimulationOptions=f,t.FluidSimulation=class{constructor(e,t=new f(64e3,128)){this.pingpong=0,this.renderer=e,this.options=t;const n=Math.pow(t.gridSize,t.dimensions);this.gridMassBuffer=e.createBuffer(new Uint32Array(n),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.gridMomentumBuffer=e.createBuffer(new Uint32Array(n*this.options.dimensions),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.gridVelocityBuffer=e.createBuffer(new Float32Array(n*this.options.dimensions),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.uniformArr=(0,l.packUniforms)(this.options.asUniformItems(),this.uniformArr),this.uniformBuffer=(0,l.uploadUniformBuffer)(this.uniformArr,this.renderer.device),this.particleBufferA=this.initializeParticleBuffer(),this.particleBufferB=this.initializeParticleBuffer();const i=e.createShaderModule({code:a.default+s.default,label:"Stage 1"}),r=e.createShaderModule({code:a.default+u.default,label:"Stage 2"}),d=e.createShaderModule({code:a.default+c.default,label:"Stage 3"}),h=Math.ceil(this.options.particles/64),_=Math.ceil(this.options.gridSize/4);this.stage1=[this.initializeComputePass("Stage 1 A",o.vec3.create(h,1,1),i,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.particleBufferA,"read-only-storage"),this.getBufferItem(this.particleBufferB,"storage")]),this.initializeComputePass("Stage 1 B",o.vec3.create(h,1,1),i,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.particleBufferB,"read-only-storage"),this.getBufferItem(this.particleBufferA,"storage")])],this.stage2=this.initializeComputePass("Stage 2",o.vec3.create(_,_,_),r,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.gridVelocityBuffer,"storage")]),this.stage3=[this.initializeComputePass("Stage 3 A",o.vec3.create(h,1,1),d,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridVelocityBuffer,"read-only-storage"),this.getBufferItem(this.particleBufferA,"read-only-storage"),this.getBufferItem(this.particleBufferB,"storage")]),this.initializeComputePass("Stage 3 B",o.vec3.create(h,1,1),d,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridVelocityBuffer,"read-only-storage"),this.getBufferItem(this.particleBufferB,"read-only-storage"),this.getBufferItem(this.particleBufferA,"storage")])];const m=144*this.options.particles;this.particleStagingBuffer=this.renderer.device.createBuffer({size:m,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ParticleStagingBuffer"}),this.particleDataForReadback=new ArrayBuffer(m),this.gridVelocityStagingBuffer=this.renderer.device.createBuffer({size:n*t.dimensions*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"VelocityStagingBuffer"})}getBufferItem(e,t){return{buffer:e,type:t,visibility:GPUShaderStage.COMPUTE}}initializeComputePass(e,t,n,i){const r=this.renderer.createComputeTask({label:e,shader:n,entryPoint:"main",dispatchCount:t,buffers:i});return{task:r,bindGroup:r.bindGroup,pipeline:this.renderer.computePipelineFor(r)}}initializeParticleBuffer(){const e=performance.now(),t={position:o.vec3.create(),velocity:o.vec3.create(),affineMatrixC:o.mat3.create(),deformationGradientF:o.mat3.identity(),mass:this.options.particleMass,Jf:1,Jp:1,materialIndex:0},n=Object.keys(t).map((e=>({name:e}))),i=(0,l.packUniforms)([{name:"Particle",type:"Particle",members:n,value:t}]),r=new Uint8Array(i),a=i.byteLength,s=a*this.options.particles,u=new Uint8Array(s),c=o.vec3.create(),f=new Uint8Array(c.buffer),d=Math.ceil(Math.cbrt(this.options.particles));for(let e=0;e<this.options.particles;e++){const t=Math.floor(e/(d*d))-.5*d,n=Math.floor(e%(d*d)/d)-.5*d,i=e%d-.5*d;c.set([t,n,i]),o.vec3.mulScalar(c,2,c),r.set(f,0),u.set(r,e*a)}const h=this.renderer.createBuffer(u,GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE);return console.log(`Created position buffer in ${performance.now()-e}ms`),h}tick(){const e=this.renderer.device.createCommandEncoder();e.clearBuffer(this.gridMassBuffer,0),e.clearBuffer(this.gridMomentumBuffer,0);const t=e.beginComputePass(),n=this.stage1[this.pingpong],i=this.stage2,r=this.stage3[this.pingpong],o=n.task.dispatchCount;t.setPipeline(n.pipeline),t.setBindGroup(0,n.bindGroup),t.dispatchWorkgroups(o[0],o[1],o[2]);const a=i.task.dispatchCount;t.setPipeline(i.pipeline),t.setBindGroup(0,i.bindGroup),t.dispatchWorkgroups(a[0],a[1],a[2]);const s=r.task.dispatchCount;t.setPipeline(r.pipeline),t.setBindGroup(0,r.bindGroup),t.dispatchWorkgroups(s[0],s[1],s[2]),t.end();const u=0===this.pingpong?this.particleBufferA:this.particleBufferB,c=144*this.options.particles;e.copyBufferToBuffer(u,0,this.particleStagingBuffer,0,c),e.copyBufferToBuffer(this.gridVelocityBuffer,0,this.gridVelocityStagingBuffer,0,this.gridVelocityBuffer.size),this.renderer.device.queue.submit([e.finish()]),this.pingpong=1-this.pingpong}inspectParticles(){return i(this,arguments,void 0,(function*(e=5){try{yield this.particleStagingBuffer.mapAsync(GPUMapMode.READ,0,this.particleStagingBuffer.size);const t=this.particleStagingBuffer.getMappedRange().slice(0);this.particleStagingBuffer.unmap();const n=[],i=144,r=new DataView(t);for(let t=0;t<Math.min(e,this.options.particles);t++){const e=t*i,a={};a.position=o.vec3.fromValues(r.getFloat32(e+0,!0),r.getFloat32(e+4,!0),r.getFloat32(e+8,!0)),a.velocity=o.vec3.fromValues(r.getFloat32(e+16,!0),r.getFloat32(e+20,!0),r.getFloat32(e+24,!0));const s=r.getFloat32(e+32,!0),u=r.getFloat32(e+36,!0),c=r.getFloat32(e+40,!0),l=r.getFloat32(e+32+16,!0),f=r.getFloat32(e+36+16,!0),d=r.getFloat32(e+40+16,!0),h=r.getFloat32(e+32+32,!0),_=r.getFloat32(e+36+32,!0),m=r.getFloat32(e+40+32,!0);a.affineMatrixC=o.mat3.create(s,u,c,l,f,d,h,_,m),r.getFloat32(e+80,!0),a.deformationGradientF=o.mat3.identity(),a.mass=r.getFloat32(e+128,!0),a.Jp=r.getFloat32(e+132,!0),a.Jf=r.getFloat32(e+136,!0),a.materialIndex=r.getUint32(e+140,!0),n.push(a)}console.log("Readback Particles:",JSON.stringify(n))}catch(e){console.error("Failed to map staging buffer or read particles:",e)}}))}inspectGridVelocities(){return i(this,arguments,void 0,(function*(e=100){try{yield this.gridVelocityStagingBuffer.mapAsync(GPUMapMode.READ,0,this.gridVelocityStagingBuffer.size);const t=this.gridVelocityStagingBuffer.getMappedRange().slice(0);this.gridVelocityStagingBuffer.unmap();const n=[],i=new DataView(t),r=Math.pow(this.options.gridSize,this.options.dimensions);for(let t=0;t<Math.min(e,r);t++){const e=3*t*4,r=i.getFloat32(e+0,!0),o=i.getFloat32(e+4,!0),a=i.getFloat32(e+8,!0);0===r&&0===o&&0===a||n.push({x:r,y:o,z:a})}n.length>0?console.log("Readback Grid Velocities (non-zero):",JSON.stringify(n,null,2)):console.log("Readback Grid Velocities: All logged cells are zero.")}catch(e){console.error("Failed to map or read grid velocity staging buffer:",e)}}))}}},534:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Camera=void 0;const i=n(717),r=n(541);class o extends r.Transform{constructor(){super(),this._isProjectionDirty=!0,this._isViewDirty=!0,this._projectionMatrix=i.mat4.identity(),this._viewMatrix=i.mat4.identity(),this._isProjectionDirty=!0,this._isViewDirty=!0}get projectionMatrix(){return this._isProjectionDirty&&this.updateProjectionMatrix(),this._projectionMatrix}get viewMatrix(){return this._isViewDirty&&this.updateViewMatrix(),this._viewMatrix}updateMatrices(){this._isProjectionDirty&&this.updateProjectionMatrix(),this._isViewDirty&&this.updateViewMatrix()}}t.Camera=o},541:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Transform=void 0;const i=n(717);t.Transform=class{constructor(){this._children=[],this._position=i.vec3.create(0,0,0),this._rotation=i.quat.identity(),this._scale=i.vec3.create(1,1,1),this._localMatrix=i.mat4.identity(),this._worldMatrix=i.mat4.identity(),this._localDirty=!0,this._worldDirty=!0}get position(){return this._position}get quaternion(){return this._rotation}get scale(){return this._scale}set position(e){i.vec3.equals(this._position,e)||(this._position=i.vec3.copy(e,this._position),this.makeDirty())}set quaternion(e){i.quat.equals(this._rotation,e)||(this._rotation=i.quat.copy(e,this._rotation),this.makeDirty())}set scale(e){i.vec3.equals(this._scale,e)||(this._scale=i.vec3.copy(e,this._scale),this.makeDirty())}setPosition(e,t,n){this.position=i.vec3.create(e,t,n)}setRotation(e,t,n,r="xyz"){this._rotation=i.quat.fromEuler(e,t,n,r),this.makeDirty()}setScale(e,t,n){this.scale=i.vec3.create(e,t,n)}get localMatrix(){return this._localDirty&&this.updateLocalMatrix(),this._localMatrix}get worldMatrix(){return(this._localDirty||this._worldDirty)&&this.updateWorldMatrix(),this._worldMatrix}updateLocalMatrix(){!function(e,t,n,r){r||(r=i.mat4.create());const[o,a,s,u]=t,c=o+o,l=a+a,f=s+s,d=o*c,h=a*l,_=s*f,m=o*l,p=o*f,g=a*f,v=u*c,y=u*l,b=u*f,[x,w,M]=n;r[0]=(1-(h+_))*x,r[1]=(m+b)*x,r[2]=(p-y)*x,r[3]=0,r[4]=(m-b)*w,r[5]=(1-(d+_))*w,r[6]=(g+v)*w,r[7]=0,r[8]=(p+y)*M,r[9]=(g-v)*M,r[10]=(1-(d+h))*M,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1}(this._position,this._rotation,this._scale,this._localMatrix),this._localDirty=!1,this._worldDirty=!0}updateWorldMatrix(){this._localDirty&&this.updateLocalMatrix(),this._parent?i.mat4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix):i.mat4.copy(this.localMatrix,this._worldMatrix),this._worldDirty=!1;for(const e of this._children)e._worldDirty=!0}makeDirty(){this._localDirty=!0,this._worldDirty=!0;for(const e of this._children)e._worldDirty||e.makeWorldDirty()}makeWorldDirty(){if(!this._worldDirty){this._worldDirty=!0;for(const e of this._children)e.makeWorldDirty()}}get children(){return this._children}add(e){e._parent!==this&&(e._parent&&e._parent.remove(e),-1===this._children.indexOf(e)&&(this._children.push(e),e._parent=this,e.makeWorldDirty()))}remove(e){const t=this._children.indexOf(e);-1!==t&&(this._children.splice(t,1),e._parent=void 0,e.makeWorldDirty())}clear(){for(const e of this._children)e._parent=void 0,e.makeWorldDirty();this._children=[]}traverse(e){e(this);for(const t of this._children)t.traverse(e)}}},599:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PerspectiveCamera=void 0;const i=n(717),r=n(534);class o extends r.Camera{constructor({fov:e=Math.PI/4,aspect:t=16/9,near:n=.1,far:r=1e3,position:o=i.vec3.create(0,0,10),target:a=i.vec3.create(0,0,0),up:s=i.vec3.create(0,1,0)}={}){super(),this.fov=e,this.aspect=t,this.near=n,this.far=r,this.position=i.vec3.clone(o),this.target=i.vec3.clone(a),this.up=i.vec3.clone(s)}updateProjectionMatrix(){console.log("Updating Projection Matrix using wgpu-matrix"),this._projectionMatrix=i.mat4.perspective(this.fov,this.aspect,this.near,this.far),this._isProjectionDirty=!1}updateViewMatrix(){console.log("Updating View Matrix using wgpu-matrix"),this._viewMatrix=i.mat4.lookAt(this.position,this.target,this.up),this._isViewDirty=!1}setPosition(e,t,n){super.setPosition(e,t,n);const r=i.vec3.create(e,t,n);i.vec3.equals(this.position,r)||(this.position=i.vec3.copy(r,this.position),this._isViewDirty=!0)}setTarget(e){i.vec3.equals(this.target,e)||(this.target=i.vec3.copy(e,this.target),this._isViewDirty=!0)}setUp(e){i.vec3.equals(this.up,e)||(this.up=i.vec3.copy(e,this.up),this._isViewDirty=!0)}setFov(e){this.fov!==e&&(this.fov=e,this._isProjectionDirty=!0)}setAspect(e){this.aspect!==e&&(this.aspect=e,this._isProjectionDirty=!0)}setNear(e){this.near!==e&&(this.near=e,this._isProjectionDirty=!0)}setFar(e){this.far!==e&&(this.far=e,this._isProjectionDirty=!0)}viewportResized(e){this.setAspect(e[0]/e[1])}}t.PerspectiveCamera=o},657:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.BigTriangle=void 0;const i=n(80);class r extends i.Geometry{constructor(e){const t=e.createBuffer(new Float32Array([-1,-1,0,0,0,0,0,1,3,-1,0,2,0,0,0,1,-1,3,0,0,2,0,0,1]),GPUBufferUsage.VERTEX),n=e.createBuffer(new Uint16Array([0,1,2]),GPUBufferUsage.INDEX);super(e,t,n,3,3)}get cacheKey(){return"big-triangle"}get bufferLayout(){return[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}],arrayStride:32,stepMode:"vertex"}]}}t.BigTriangle=r},710:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Color=void 0;const i=n(717);t.Color=class{constructor(e,t,n,i=1){this.r=e,this.g=t,this.b=n,this.a=i}uniformValue(){var e;return null!==(e=this.buffer)&&void 0!==e||(this.buffer=i.vec4.create()),this.buffer.set([this.r,this.g,this.b,this.a]),this.buffer}}},717:(e,t,n)=>{n.r(t),n.d(t,{mat3:()=>x,mat3d:()=>D,mat3n:()=>A,mat4:()=>w,mat4d:()=>C,mat4n:()=>T,quat:()=>M,quatd:()=>U,quatn:()=>I,utils:()=>s,vec2:()=>P,vec2d:()=>z,vec2n:()=>V,vec3:()=>S,vec3d:()=>O,vec3n:()=>j,vec4:()=>B,vec4d:()=>G,vec4n:()=>F});const i=(r=Array,o=e=>e.fill(0),class extends r{constructor(...e){super(...e),o(this)}});var r,o;let a=1e-6;var s={__proto__:null,get EPSILON(){return a},degToRad:function(e){return e*Math.PI/180},euclideanModulo:function(e,t){return(e%t+t)%t},inverseLerp:function(e,t,n){const i=t-e;return Math.abs(t-e)<a?e:(n-e)/i},lerp:function(e,t,n){return e+(t-e)*n},radToDeg:function(e){return 180*e/Math.PI},setEpsilon:function(e){const t=a;return a=e,t}};const u=new Map;function c(e){let t=u.get(e);return t||(t=function(e){function t(t=0,n=0){const i=new e(2);return void 0!==t&&(i[0]=t,void 0!==n&&(i[1]=n)),i}function n(t,n,i){const r=i??new e(2);return r[0]=t[0]-n[0],r[1]=t[1]-n[1],r}function i(t,n,i,r){const o=r??new e(2);return o[0]=t[0]+i*(n[0]-t[0]),o[1]=t[1]+i*(n[1]-t[1]),o}function r(t,n,i){const r=i??new e(2);return r[0]=t[0]*n,r[1]=t[1]*n,r}function o(t,n){const i=n??new e(2);return i[0]=1/t[0],i[1]=1/t[1],i}function s(e,t){return e[0]*t[0]+e[1]*t[1]}function u(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}function c(e){const t=e[0],n=e[1];return t*t+n*n}function l(e,t){const n=e[0]-t[0],i=e[1]-t[1];return Math.sqrt(n*n+i*i)}function f(e,t){const n=e[0]-t[0],i=e[1]-t[1];return n*n+i*i}function d(t,n){const i=n??new e(2),r=t[0],o=t[1],a=Math.sqrt(r*r+o*o);return a>1e-5?(i[0]=r/a,i[1]=o/a):(i[0]=0,i[1]=0),i}function h(t,n){const i=n??new e(2);return i[0]=t[0],i[1]=t[1],i}function _(t,n,i){const r=i??new e(2);return r[0]=t[0]*n[0],r[1]=t[1]*n[1],r}function m(t,n,i){const r=i??new e(2);return r[0]=t[0]/n[0],r[1]=t[1]/n[1],r}function p(t,n,i){const o=i??new e(2);return d(t,o),r(o,n,o)}return{create:t,fromValues:t,set:function(t,n,i){const r=i??new e(2);return r[0]=t,r[1]=n,r},ceil:function(t,n){const i=n??new e(2);return i[0]=Math.ceil(t[0]),i[1]=Math.ceil(t[1]),i},floor:function(t,n){const i=n??new e(2);return i[0]=Math.floor(t[0]),i[1]=Math.floor(t[1]),i},round:function(t,n){const i=n??new e(2);return i[0]=Math.round(t[0]),i[1]=Math.round(t[1]),i},clamp:function(t,n=0,i=1,r){const o=r??new e(2);return o[0]=Math.min(i,Math.max(n,t[0])),o[1]=Math.min(i,Math.max(n,t[1])),o},add:function(t,n,i){const r=i??new e(2);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r},addScaled:function(t,n,i,r){const o=r??new e(2);return o[0]=t[0]+n[0]*i,o[1]=t[1]+n[1]*i,o},angle:function(e,t){const n=e[0],i=e[1],r=t[0],o=t[1],a=Math.sqrt(n*n+i*i)*Math.sqrt(r*r+o*o),u=a&&s(e,t)/a;return Math.acos(u)},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:i,lerpV:function(t,n,i,r){const o=r??new e(2);return o[0]=t[0]+i[0]*(n[0]-t[0]),o[1]=t[1]+i[1]*(n[1]-t[1]),o},max:function(t,n,i){const r=i??new e(2);return r[0]=Math.max(t[0],n[0]),r[1]=Math.max(t[1],n[1]),r},min:function(t,n,i){const r=i??new e(2);return r[0]=Math.min(t[0],n[0]),r[1]=Math.min(t[1],n[1]),r},mulScalar:r,scale:r,divScalar:function(t,n,i){const r=i??new e(2);return r[0]=t[0]/n,r[1]=t[1]/n,r},inverse:o,invert:o,cross:function(t,n,i){const r=i??new e(3),o=t[0]*n[1]-t[1]*n[0];return r[0]=0,r[1]=0,r[2]=o,r},dot:s,length:u,len:u,lengthSq:c,lenSq:c,distance:l,dist:l,distanceSq:f,distSq:f,normalize:d,negate:function(t,n){const i=n??new e(2);return i[0]=-t[0],i[1]=-t[1],i},copy:h,clone:h,multiply:_,mul:_,divide:m,div:m,random:function(t=1,n){const i=n??new e(2),r=2*Math.random()*Math.PI;return i[0]=Math.cos(r)*t,i[1]=Math.sin(r)*t,i},zero:function(t){const n=t??new e(2);return n[0]=0,n[1]=0,n},transformMat4:function(t,n,i){const r=i??new e(2),o=t[0],a=t[1];return r[0]=o*n[0]+a*n[4]+n[12],r[1]=o*n[1]+a*n[5]+n[13],r},transformMat3:function(t,n,i){const r=i??new e(2),o=t[0],a=t[1];return r[0]=n[0]*o+n[4]*a+n[8],r[1]=n[1]*o+n[5]*a+n[9],r},rotate:function(t,n,i,r){const o=r??new e(2),a=t[0]-n[0],s=t[1]-n[1],u=Math.sin(i),c=Math.cos(i);return o[0]=a*c-s*u+n[0],o[1]=a*u+s*c+n[1],o},setLength:p,truncate:function(t,n,i){const r=i??new e(2);return u(t)>n?p(t,n,r):h(t,r)},midpoint:function(t,n,r){return i(t,n,.5,r??new e(2))}}}(e),u.set(e,t)),t}const l=new Map;function f(e){let t=l.get(e);return t||(t=function(e){function t(t,n,i){const r=new e(3);return void 0!==t&&(r[0]=t,void 0!==n&&(r[1]=n,void 0!==i&&(r[2]=i))),r}function n(t,n,i){const r=i??new e(3);return r[0]=t[0]-n[0],r[1]=t[1]-n[1],r[2]=t[2]-n[2],r}function i(t,n,i,r){const o=r??new e(3);return o[0]=t[0]+i*(n[0]-t[0]),o[1]=t[1]+i*(n[1]-t[1]),o[2]=t[2]+i*(n[2]-t[2]),o}function r(t,n,i){const r=i??new e(3);return r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r}function o(t,n){const i=n??new e(3);return i[0]=1/t[0],i[1]=1/t[1],i[2]=1/t[2],i}function s(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function u(e){const t=e[0],n=e[1],i=e[2];return Math.sqrt(t*t+n*n+i*i)}function c(e){const t=e[0],n=e[1],i=e[2];return t*t+n*n+i*i}function l(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2];return Math.sqrt(n*n+i*i+r*r)}function f(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2];return n*n+i*i+r*r}function d(t,n){const i=n??new e(3),r=t[0],o=t[1],a=t[2],s=Math.sqrt(r*r+o*o+a*a);return s>1e-5?(i[0]=r/s,i[1]=o/s,i[2]=a/s):(i[0]=0,i[1]=0,i[2]=0),i}function h(t,n){const i=n??new e(3);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i}function _(t,n,i){const r=i??new e(3);return r[0]=t[0]*n[0],r[1]=t[1]*n[1],r[2]=t[2]*n[2],r}function m(t,n,i){const r=i??new e(3);return r[0]=t[0]/n[0],r[1]=t[1]/n[1],r[2]=t[2]/n[2],r}function p(t,n,i){const o=i??new e(3);return d(t,o),r(o,n,o)}return{create:t,fromValues:t,set:function(t,n,i,r){const o=r??new e(3);return o[0]=t,o[1]=n,o[2]=i,o},ceil:function(t,n){const i=n??new e(3);return i[0]=Math.ceil(t[0]),i[1]=Math.ceil(t[1]),i[2]=Math.ceil(t[2]),i},floor:function(t,n){const i=n??new e(3);return i[0]=Math.floor(t[0]),i[1]=Math.floor(t[1]),i[2]=Math.floor(t[2]),i},round:function(t,n){const i=n??new e(3);return i[0]=Math.round(t[0]),i[1]=Math.round(t[1]),i[2]=Math.round(t[2]),i},clamp:function(t,n=0,i=1,r){const o=r??new e(3);return o[0]=Math.min(i,Math.max(n,t[0])),o[1]=Math.min(i,Math.max(n,t[1])),o[2]=Math.min(i,Math.max(n,t[2])),o},add:function(t,n,i){const r=i??new e(3);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r[2]=t[2]+n[2],r},addScaled:function(t,n,i,r){const o=r??new e(3);return o[0]=t[0]+n[0]*i,o[1]=t[1]+n[1]*i,o[2]=t[2]+n[2]*i,o},angle:function(e,t){const n=e[0],i=e[1],r=e[2],o=t[0],a=t[1],u=t[2],c=Math.sqrt(n*n+i*i+r*r)*Math.sqrt(o*o+a*a+u*u),l=c&&s(e,t)/c;return Math.acos(l)},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:i,lerpV:function(t,n,i,r){const o=r??new e(3);return o[0]=t[0]+i[0]*(n[0]-t[0]),o[1]=t[1]+i[1]*(n[1]-t[1]),o[2]=t[2]+i[2]*(n[2]-t[2]),o},max:function(t,n,i){const r=i??new e(3);return r[0]=Math.max(t[0],n[0]),r[1]=Math.max(t[1],n[1]),r[2]=Math.max(t[2],n[2]),r},min:function(t,n,i){const r=i??new e(3);return r[0]=Math.min(t[0],n[0]),r[1]=Math.min(t[1],n[1]),r[2]=Math.min(t[2],n[2]),r},mulScalar:r,scale:r,divScalar:function(t,n,i){const r=i??new e(3);return r[0]=t[0]/n,r[1]=t[1]/n,r[2]=t[2]/n,r},inverse:o,invert:o,cross:function(t,n,i){const r=i??new e(3),o=t[2]*n[0]-t[0]*n[2],a=t[0]*n[1]-t[1]*n[0];return r[0]=t[1]*n[2]-t[2]*n[1],r[1]=o,r[2]=a,r},dot:s,length:u,len:u,lengthSq:c,lenSq:c,distance:l,dist:l,distanceSq:f,distSq:f,normalize:d,negate:function(t,n){const i=n??new e(3);return i[0]=-t[0],i[1]=-t[1],i[2]=-t[2],i},copy:h,clone:h,multiply:_,mul:_,divide:m,div:m,random:function(t=1,n){const i=n??new e(3),r=2*Math.random()*Math.PI,o=2*Math.random()-1,a=Math.sqrt(1-o*o)*t;return i[0]=Math.cos(r)*a,i[1]=Math.sin(r)*a,i[2]=o*t,i},zero:function(t){const n=t??new e(3);return n[0]=0,n[1]=0,n[2]=0,n},transformMat4:function(t,n,i){const r=i??new e(3),o=t[0],a=t[1],s=t[2],u=n[3]*o+n[7]*a+n[11]*s+n[15]||1;return r[0]=(n[0]*o+n[4]*a+n[8]*s+n[12])/u,r[1]=(n[1]*o+n[5]*a+n[9]*s+n[13])/u,r[2]=(n[2]*o+n[6]*a+n[10]*s+n[14])/u,r},transformMat4Upper3x3:function(t,n,i){const r=i??new e(3),o=t[0],a=t[1],s=t[2];return r[0]=o*n[0]+a*n[4]+s*n[8],r[1]=o*n[1]+a*n[5]+s*n[9],r[2]=o*n[2]+a*n[6]+s*n[10],r},transformMat3:function(t,n,i){const r=i??new e(3),o=t[0],a=t[1],s=t[2];return r[0]=o*n[0]+a*n[4]+s*n[8],r[1]=o*n[1]+a*n[5]+s*n[9],r[2]=o*n[2]+a*n[6]+s*n[10],r},transformQuat:function(t,n,i){const r=i??new e(3),o=n[0],a=n[1],s=n[2],u=2*n[3],c=t[0],l=t[1],f=t[2],d=a*f-s*l,h=s*c-o*f,_=o*l-a*c;return r[0]=c+d*u+2*(a*_-s*h),r[1]=l+h*u+2*(s*d-o*_),r[2]=f+_*u+2*(o*h-a*d),r},getTranslation:function(t,n){const i=n??new e(3);return i[0]=t[12],i[1]=t[13],i[2]=t[14],i},getAxis:function(t,n,i){const r=i??new e(3),o=4*n;return r[0]=t[o+0],r[1]=t[o+1],r[2]=t[o+2],r},getScaling:function(t,n){const i=n??new e(3),r=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10];return i[0]=Math.sqrt(r*r+o*o+a*a),i[1]=Math.sqrt(s*s+u*u+c*c),i[2]=Math.sqrt(l*l+f*f+d*d),i},rotateX:function(t,n,i,r){const o=r??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[0],s[1]=a[1]*Math.cos(i)-a[2]*Math.sin(i),s[2]=a[1]*Math.sin(i)+a[2]*Math.cos(i),o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},rotateY:function(t,n,i,r){const o=r??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[2]*Math.sin(i)+a[0]*Math.cos(i),s[1]=a[1],s[2]=a[2]*Math.cos(i)-a[0]*Math.sin(i),o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},rotateZ:function(t,n,i,r){const o=r??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[0]*Math.cos(i)-a[1]*Math.sin(i),s[1]=a[0]*Math.sin(i)+a[1]*Math.cos(i),s[2]=a[2],o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},setLength:p,truncate:function(t,n,i){const r=i??new e(3);return u(t)>n?p(t,n,r):h(t,r)},midpoint:function(t,n,r){return i(t,n,.5,r??new e(3))}}}(e),l.set(e,t)),t}const d=new Map;function h(e){let t=d.get(e);return t||(t=function(e){const t=c(e),n=f(e);function i(t,n,i){const r=i??new e(12);return r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r[4]=t[4]*n,r[5]=t[5]*n,r[6]=t[6]*n,r[8]=t[8]*n,r[9]=t[9]*n,r[10]=t[10]*n,r}function r(t,n){const i=n??new e(12);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[8]=t[8],i[9]=t[9],i[10]=t[10],i}function o(t){const n=t??new e(12);return n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n}function s(t,n){const i=n??new e(12),r=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10],h=d*u-c*f,_=-d*s+c*l,m=f*s-u*l,p=1/(r*h+o*_+a*m);return i[0]=h*p,i[1]=(-d*o+a*f)*p,i[2]=(c*o-a*u)*p,i[4]=_*p,i[5]=(d*r-a*l)*p,i[6]=(-c*r+a*s)*p,i[8]=m*p,i[9]=(-f*r+o*l)*p,i[10]=(u*r-o*s)*p,i}function u(t,n,i){const r=i??new e(12),o=t[0],a=t[1],s=t[2],u=t[4],c=t[5],l=t[6],f=t[8],d=t[9],h=t[10],_=n[0],m=n[1],p=n[2],g=n[4],v=n[5],y=n[6],b=n[8],x=n[9],w=n[10];return r[0]=o*_+u*m+f*p,r[1]=a*_+c*m+d*p,r[2]=s*_+l*m+h*p,r[4]=o*g+u*v+f*y,r[5]=a*g+c*v+d*y,r[6]=s*g+l*v+h*y,r[8]=o*b+u*x+f*w,r[9]=a*b+c*x+d*w,r[10]=s*b+l*x+h*w,r}function l(t,n){const i=n??new e(12),r=Math.cos(t),o=Math.sin(t);return i[0]=r,i[1]=o,i[2]=0,i[4]=-o,i[5]=r,i[6]=0,i[8]=0,i[9]=0,i[10]=1,i}function d(t,n,i){const r=i??new e(12),o=t[0],a=t[1],s=t[2],u=t[4],c=t[5],l=t[6],f=Math.cos(n),d=Math.sin(n);return r[0]=f*o+d*u,r[1]=f*a+d*c,r[2]=f*s+d*l,r[4]=f*u-d*o,r[5]=f*c-d*a,r[6]=f*l-d*s,t!==r&&(r[8]=t[8],r[9]=t[9],r[10]=t[10]),r}return{add:function(t,n,i){const r=i??new e(12);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r[2]=t[2]+n[2],r[4]=t[4]+n[4],r[5]=t[5]+n[5],r[6]=t[6]+n[6],r[8]=t[8]+n[8],r[9]=t[9]+n[9],r[10]=t[10]+n[10],r},clone:r,copy:r,create:function(t,n,i,r,o,a,s,u,c){const l=new e(12);return l[3]=0,l[7]=0,l[11]=0,void 0!==t&&(l[0]=t,void 0!==n&&(l[1]=n,void 0!==i&&(l[2]=i,void 0!==r&&(l[4]=r,void 0!==o&&(l[5]=o,void 0!==a&&(l[6]=a,void 0!==s&&(l[8]=s,void 0!==u&&(l[9]=u,void 0!==c&&(l[10]=c))))))))),l},determinant:function(e){const t=e[0],n=e[1],i=e[2],r=e[4],o=e[5],a=e[6],s=e[8],u=e[9],c=e[10];return t*(o*c-u*a)-r*(n*c-u*i)+s*(n*a-o*i)},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]},equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[4]-t[4])<a&&Math.abs(e[5]-t[5])<a&&Math.abs(e[6]-t[6])<a&&Math.abs(e[8]-t[8])<a&&Math.abs(e[9]-t[9])<a&&Math.abs(e[10]-t[10])<a},fromMat4:function(t,n){const i=n??new e(12);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=0,i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=0,i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=0,i},fromQuat:function(t,n){const i=n??new e(12),r=t[0],o=t[1],a=t[2],s=t[3],u=r+r,c=o+o,l=a+a,f=r*u,d=o*u,h=o*c,_=a*u,m=a*c,p=a*l,g=s*u,v=s*c,y=s*l;return i[0]=1-h-p,i[1]=d+y,i[2]=_-v,i[3]=0,i[4]=d-y,i[5]=1-f-p,i[6]=m+g,i[7]=0,i[8]=_+v,i[9]=m-g,i[10]=1-f-h,i[11]=0,i},get3DScaling:function(e,t){const i=t??n.create(),r=e[0],o=e[1],a=e[2],s=e[4],u=e[5],c=e[6],l=e[8],f=e[9],d=e[10];return i[0]=Math.sqrt(r*r+o*o+a*a),i[1]=Math.sqrt(s*s+u*u+c*c),i[2]=Math.sqrt(l*l+f*f+d*d),i},getAxis:function(e,n,i){const r=i??t.create(),o=4*n;return r[0]=e[o+0],r[1]=e[o+1],r},getScaling:function(e,n){const i=n??t.create(),r=e[0],o=e[1],a=e[4],s=e[5];return i[0]=Math.sqrt(r*r+o*o),i[1]=Math.sqrt(a*a+s*s),i},getTranslation:function(e,n){const i=n??t.create();return i[0]=e[8],i[1]=e[9],i},identity:o,inverse:s,invert:s,mul:u,mulScalar:i,multiply:u,multiplyScalar:i,negate:function(t,n){const i=n??new e(12);return i[0]=-t[0],i[1]=-t[1],i[2]=-t[2],i[4]=-t[4],i[5]=-t[5],i[6]=-t[6],i[8]=-t[8],i[9]=-t[9],i[10]=-t[10],i},rotate:d,rotateX:function(t,n,i){const r=i??new e(12),o=t[4],a=t[5],s=t[6],u=t[8],c=t[9],l=t[10],f=Math.cos(n),d=Math.sin(n);return r[4]=f*o+d*u,r[5]=f*a+d*c,r[6]=f*s+d*l,r[8]=f*u-d*o,r[9]=f*c-d*a,r[10]=f*l-d*s,t!==r&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),r},rotateY:function(t,n,i){const r=i??new e(12),o=t[0],a=t[1],s=t[2],u=t[8],c=t[9],l=t[10],f=Math.cos(n),d=Math.sin(n);return r[0]=f*o-d*u,r[1]=f*a-d*c,r[2]=f*s-d*l,r[8]=f*u+d*o,r[9]=f*c+d*a,r[10]=f*l+d*s,t!==r&&(r[4]=t[4],r[5]=t[5],r[6]=t[6]),r},rotateZ:d,rotation:l,rotationX:function(t,n){const i=n??new e(12),r=Math.cos(t),o=Math.sin(t);return i[0]=1,i[1]=0,i[2]=0,i[4]=0,i[5]=r,i[6]=o,i[8]=0,i[9]=-o,i[10]=r,i},rotationY:function(t,n){const i=n??new e(12),r=Math.cos(t),o=Math.sin(t);return i[0]=r,i[1]=0,i[2]=-o,i[4]=0,i[5]=1,i[6]=0,i[8]=o,i[9]=0,i[10]=r,i},rotationZ:l,scale:function(t,n,i){const r=i??new e(12),o=n[0],a=n[1];return r[0]=o*t[0],r[1]=o*t[1],r[2]=o*t[2],r[4]=a*t[4],r[5]=a*t[5],r[6]=a*t[6],t!==r&&(r[8]=t[8],r[9]=t[9],r[10]=t[10]),r},scale3D:function(t,n,i){const r=i??new e(12),o=n[0],a=n[1],s=n[2];return r[0]=o*t[0],r[1]=o*t[1],r[2]=o*t[2],r[4]=a*t[4],r[5]=a*t[5],r[6]=a*t[6],r[8]=s*t[8],r[9]=s*t[9],r[10]=s*t[10],r},scaling:function(t,n){const i=n??new e(12);return i[0]=t[0],i[1]=0,i[2]=0,i[4]=0,i[5]=t[1],i[6]=0,i[8]=0,i[9]=0,i[10]=1,i},scaling3D:function(t,n){const i=n??new e(12);return i[0]=t[0],i[1]=0,i[2]=0,i[4]=0,i[5]=t[1],i[6]=0,i[8]=0,i[9]=0,i[10]=t[2],i},set:function(t,n,i,r,o,a,s,u,c,l){const f=l??new e(12);return f[0]=t,f[1]=n,f[2]=i,f[3]=0,f[4]=r,f[5]=o,f[6]=a,f[7]=0,f[8]=s,f[9]=u,f[10]=c,f[11]=0,f},setAxis:function(e,t,n,i){const o=i===e?e:r(e,i),a=4*n;return o[a+0]=t[0],o[a+1]=t[1],o},setTranslation:function(e,t,n){const i=n??o();return e!==i&&(i[0]=e[0],i[1]=e[1],i[2]=e[2],i[4]=e[4],i[5]=e[5],i[6]=e[6]),i[8]=t[0],i[9]=t[1],i[10]=1,i},translate:function(t,n,i){const r=i??new e(12),o=n[0],a=n[1],s=t[0],u=t[1],c=t[2],l=t[4],f=t[5],d=t[6],h=t[8],_=t[9],m=t[10];return t!==r&&(r[0]=s,r[1]=u,r[2]=c,r[4]=l,r[5]=f,r[6]=d),r[8]=s*o+l*a+h,r[9]=u*o+f*a+_,r[10]=c*o+d*a+m,r},translation:function(t,n){const i=n??new e(12);return i[0]=1,i[1]=0,i[2]=0,i[4]=0,i[5]=1,i[6]=0,i[8]=t[0],i[9]=t[1],i[10]=1,i},transpose:function(t,n){const i=n??new e(12);if(i===t){let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,i}const r=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10];return i[0]=r,i[1]=s,i[2]=l,i[4]=o,i[5]=u,i[6]=f,i[8]=a,i[9]=c,i[10]=d,i},uniformScale:function(t,n,i){const r=i??new e(12);return r[0]=n*t[0],r[1]=n*t[1],r[2]=n*t[2],r[4]=n*t[4],r[5]=n*t[5],r[6]=n*t[6],t!==r&&(r[8]=t[8],r[9]=t[9],r[10]=t[10]),r},uniformScale3D:function(t,n,i){const r=i??new e(12);return r[0]=n*t[0],r[1]=n*t[1],r[2]=n*t[2],r[4]=n*t[4],r[5]=n*t[5],r[6]=n*t[6],r[8]=n*t[8],r[9]=n*t[9],r[10]=n*t[10],r},uniformScaling:function(t,n){const i=n??new e(12);return i[0]=t,i[1]=0,i[2]=0,i[4]=0,i[5]=t,i[6]=0,i[8]=0,i[9]=0,i[10]=1,i},uniformScaling3D:function(t,n){const i=n??new e(12);return i[0]=t,i[1]=0,i[2]=0,i[4]=0,i[5]=t,i[6]=0,i[8]=0,i[9]=0,i[10]=t,i}}}(e),d.set(e,t)),t}const _=new Map;function m(e){let t=_.get(e);return t||(t=function(e){const t=f(e);function n(t,n,i){const r=i??new e(16);return r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r[3]=t[3]*n,r[4]=t[4]*n,r[5]=t[5]*n,r[6]=t[6]*n,r[7]=t[7]*n,r[8]=t[8]*n,r[9]=t[9]*n,r[10]=t[10]*n,r[11]=t[11]*n,r[12]=t[12]*n,r[13]=t[13]*n,r[14]=t[14]*n,r[15]=t[15]*n,r}const i=n;function r(t,n){const i=n??new e(16);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15],i}const o=r;function s(t){const n=t??new e(16);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function u(t,n){const i=n??new e(16),r=t[0],o=t[1],a=t[2],s=t[3],u=t[4],c=t[5],l=t[6],f=t[7],d=t[8],h=t[9],_=t[10],m=t[11],p=t[12],g=t[13],v=t[14],y=t[15],b=_*y,x=v*m,w=l*y,M=v*f,P=l*m,S=_*f,B=a*y,D=v*s,C=a*m,U=_*s,z=a*f,O=l*s,G=d*g,A=p*h,T=u*g,I=p*c,V=u*h,j=d*c,F=r*g,E=p*o,q=r*h,L=d*o,N=r*c,R=u*o,k=b*c+M*h+P*g-(x*c+w*h+S*g),$=x*o+B*h+U*g-(b*o+D*h+C*g),Y=w*o+D*c+z*g-(M*o+B*c+O*g),K=S*o+C*c+O*h-(P*o+U*c+z*h),X=1/(r*k+u*$+d*Y+p*K);return i[0]=X*k,i[1]=X*$,i[2]=X*Y,i[3]=X*K,i[4]=X*(x*u+w*d+S*p-(b*u+M*d+P*p)),i[5]=X*(b*r+D*d+C*p-(x*r+B*d+U*p)),i[6]=X*(M*r+B*u+O*p-(w*r+D*u+z*p)),i[7]=X*(P*r+U*u+z*d-(S*r+C*u+O*d)),i[8]=X*(G*f+I*m+V*y-(A*f+T*m+j*y)),i[9]=X*(A*s+F*m+L*y-(G*s+E*m+q*y)),i[10]=X*(T*s+E*f+N*y-(I*s+F*f+R*y)),i[11]=X*(j*s+q*f+R*m-(V*s+L*f+N*m)),i[12]=X*(T*_+j*v+A*l-(V*v+G*l+I*_)),i[13]=X*(q*v+G*a+E*_-(F*_+L*v+A*a)),i[14]=X*(F*l+R*v+I*a-(N*v+T*a+E*l)),i[15]=X*(N*_+V*a+L*l-(q*l+R*_+j*a)),i}const c=u;function l(t,n,i){const r=i??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[4],l=t[5],f=t[6],d=t[7],h=t[8],_=t[9],m=t[10],p=t[11],g=t[12],v=t[13],y=t[14],b=t[15],x=n[0],w=n[1],M=n[2],P=n[3],S=n[4],B=n[5],D=n[6],C=n[7],U=n[8],z=n[9],O=n[10],G=n[11],A=n[12],T=n[13],I=n[14],V=n[15];return r[0]=o*x+c*w+h*M+g*P,r[1]=a*x+l*w+_*M+v*P,r[2]=s*x+f*w+m*M+y*P,r[3]=u*x+d*w+p*M+b*P,r[4]=o*S+c*B+h*D+g*C,r[5]=a*S+l*B+_*D+v*C,r[6]=s*S+f*B+m*D+y*C,r[7]=u*S+d*B+p*D+b*C,r[8]=o*U+c*z+h*O+g*G,r[9]=a*U+l*z+_*O+v*G,r[10]=s*U+f*z+m*O+y*G,r[11]=u*U+d*z+p*O+b*G,r[12]=o*A+c*T+h*I+g*V,r[13]=a*A+l*T+_*I+v*V,r[14]=s*A+f*T+m*I+y*V,r[15]=u*A+d*T+p*I+b*V,r}const d=l,h=t.create(),_=t.create(),m=t.create();function p(t,n,i){const r=i??new e(16);let o=t[0],a=t[1],s=t[2];const u=Math.sqrt(o*o+a*a+s*s);o/=u,a/=u,s/=u;const c=o*o,l=a*a,f=s*s,d=Math.cos(n),h=Math.sin(n),_=1-d;return r[0]=c+(1-c)*d,r[1]=o*a*_+s*h,r[2]=o*s*_-a*h,r[3]=0,r[4]=o*a*_-s*h,r[5]=l+(1-l)*d,r[6]=a*s*_+o*h,r[7]=0,r[8]=o*s*_+a*h,r[9]=a*s*_-o*h,r[10]=f+(1-f)*d,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function g(t,n,i,r){const o=r??new e(16);let a=n[0],s=n[1],u=n[2];const c=Math.sqrt(a*a+s*s+u*u);a/=c,s/=c,u/=c;const l=a*a,f=s*s,d=u*u,h=Math.cos(i),_=Math.sin(i),m=1-h,p=l+(1-l)*h,g=a*s*m+u*_,v=a*u*m-s*_,y=a*s*m-u*_,b=f+(1-f)*h,x=s*u*m+a*_,w=a*u*m+s*_,M=s*u*m-a*_,P=d+(1-d)*h,S=t[0],B=t[1],D=t[2],C=t[3],U=t[4],z=t[5],O=t[6],G=t[7],A=t[8],T=t[9],I=t[10],V=t[11];return o[0]=p*S+g*U+v*A,o[1]=p*B+g*z+v*T,o[2]=p*D+g*O+v*I,o[3]=p*C+g*G+v*V,o[4]=y*S+b*U+x*A,o[5]=y*B+b*z+x*T,o[6]=y*D+b*O+x*I,o[7]=y*C+b*G+x*V,o[8]=w*S+M*U+P*A,o[9]=w*B+M*z+P*T,o[10]=w*D+M*O+P*I,o[11]=w*C+M*G+P*V,t!==o&&(o[12]=t[12],o[13]=t[13],o[14]=t[14],o[15]=t[15]),o}return{add:function(t,n,i){const r=i??new e(16);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r[2]=t[2]+n[2],r[3]=t[3]+n[3],r[4]=t[4]+n[4],r[5]=t[5]+n[5],r[6]=t[6]+n[6],r[7]=t[7]+n[7],r[8]=t[8]+n[8],r[9]=t[9]+n[9],r[10]=t[10]+n[10],r[11]=t[11]+n[11],r[12]=t[12]+n[12],r[13]=t[13]+n[13],r[14]=t[14]+n[14],r[15]=t[15]+n[15],r},aim:function(n,i,r,o){const a=o??new e(16);return t.normalize(t.subtract(i,n,m),m),t.normalize(t.cross(r,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=h[1],a[2]=h[2],a[3]=0,a[4]=_[0],a[5]=_[1],a[6]=_[2],a[7]=0,a[8]=m[0],a[9]=m[1],a[10]=m[2],a[11]=0,a[12]=n[0],a[13]=n[1],a[14]=n[2],a[15]=1,a},axisRotate:g,axisRotation:p,cameraAim:function(n,i,r,o){const a=o??new e(16);return t.normalize(t.subtract(n,i,m),m),t.normalize(t.cross(r,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=h[1],a[2]=h[2],a[3]=0,a[4]=_[0],a[5]=_[1],a[6]=_[2],a[7]=0,a[8]=m[0],a[9]=m[1],a[10]=m[2],a[11]=0,a[12]=n[0],a[13]=n[1],a[14]=n[2],a[15]=1,a},clone:o,copy:r,create:function(t,n,i,r,o,a,s,u,c,l,f,d,h,_,m,p){const g=new e(16);return void 0!==t&&(g[0]=t,void 0!==n&&(g[1]=n,void 0!==i&&(g[2]=i,void 0!==r&&(g[3]=r,void 0!==o&&(g[4]=o,void 0!==a&&(g[5]=a,void 0!==s&&(g[6]=s,void 0!==u&&(g[7]=u,void 0!==c&&(g[8]=c,void 0!==l&&(g[9]=l,void 0!==f&&(g[10]=f,void 0!==d&&(g[11]=d,void 0!==h&&(g[12]=h,void 0!==_&&(g[13]=_,void 0!==m&&(g[14]=m,void 0!==p&&(g[15]=p)))))))))))))))),g},determinant:function(e){const t=e[0],n=e[1],i=e[2],r=e[3],o=e[4],a=e[5],s=e[6],u=e[7],c=e[8],l=e[9],f=e[10],d=e[11],h=e[12],_=e[13],m=e[14],p=e[15],g=f*p,v=m*d,y=s*p,b=m*u,x=s*d,w=f*u,M=i*p,P=m*r,S=i*d,B=f*r,D=i*u,C=s*r;return t*(g*a+b*l+x*_-(v*a+y*l+w*_))+o*(v*n+M*l+B*_-(g*n+P*l+S*_))+c*(y*n+P*a+D*_-(b*n+M*a+C*_))+h*(w*n+S*a+C*l-(x*n+B*a+D*l))},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a&&Math.abs(e[4]-t[4])<a&&Math.abs(e[5]-t[5])<a&&Math.abs(e[6]-t[6])<a&&Math.abs(e[7]-t[7])<a&&Math.abs(e[8]-t[8])<a&&Math.abs(e[9]-t[9])<a&&Math.abs(e[10]-t[10])<a&&Math.abs(e[11]-t[11])<a&&Math.abs(e[12]-t[12])<a&&Math.abs(e[13]-t[13])<a&&Math.abs(e[14]-t[14])<a&&Math.abs(e[15]-t[15])<a},fromMat3:function(t,n){const i=n??new e(16);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=0,i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=0,i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromQuat:function(t,n){const i=n??new e(16),r=t[0],o=t[1],a=t[2],s=t[3],u=r+r,c=o+o,l=a+a,f=r*u,d=o*u,h=o*c,_=a*u,m=a*c,p=a*l,g=s*u,v=s*c,y=s*l;return i[0]=1-h-p,i[1]=d+y,i[2]=_-v,i[3]=0,i[4]=d-y,i[5]=1-f-p,i[6]=m+g,i[7]=0,i[8]=_+v,i[9]=m-g,i[10]=1-f-h,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},frustum:function(t,n,i,r,o,a,s){const u=s??new e(16),c=n-t,l=r-i,f=o-a;return u[0]=2*o/c,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2*o/l,u[6]=0,u[7]=0,u[8]=(t+n)/c,u[9]=(r+i)/l,u[10]=a/f,u[11]=-1,u[12]=0,u[13]=0,u[14]=o*a/f,u[15]=0,u},frustumReverseZ:function(t,n,i,r,o,a=1/0,s){const u=s??new e(16),c=n-t,l=r-i;if(u[0]=2*o/c,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2*o/l,u[6]=0,u[7]=0,u[8]=(t+n)/c,u[9]=(r+i)/l,u[11]=-1,u[12]=0,u[13]=0,u[15]=0,a===1/0)u[10]=0,u[14]=o;else{const e=1/(a-o);u[10]=o*e,u[14]=a*o*e}return u},getAxis:function(e,n,i){const r=i??t.create(),o=4*n;return r[0]=e[o+0],r[1]=e[o+1],r[2]=e[o+2],r},getScaling:function(e,n){const i=n??t.create(),r=e[0],o=e[1],a=e[2],s=e[4],u=e[5],c=e[6],l=e[8],f=e[9],d=e[10];return i[0]=Math.sqrt(r*r+o*o+a*a),i[1]=Math.sqrt(s*s+u*u+c*c),i[2]=Math.sqrt(l*l+f*f+d*d),i},getTranslation:function(e,n){const i=n??t.create();return i[0]=e[12],i[1]=e[13],i[2]=e[14],i},identity:s,inverse:u,invert:c,lookAt:function(n,i,r,o){const a=o??new e(16);return t.normalize(t.subtract(n,i,m),m),t.normalize(t.cross(r,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=_[0],a[2]=m[0],a[3]=0,a[4]=h[1],a[5]=_[1],a[6]=m[1],a[7]=0,a[8]=h[2],a[9]=_[2],a[10]=m[2],a[11]=0,a[12]=-(h[0]*n[0]+h[1]*n[1]+h[2]*n[2]),a[13]=-(_[0]*n[0]+_[1]*n[1]+_[2]*n[2]),a[14]=-(m[0]*n[0]+m[1]*n[1]+m[2]*n[2]),a[15]=1,a},mul:d,mulScalar:i,multiply:l,multiplyScalar:n,negate:function(t,n){const i=n??new e(16);return i[0]=-t[0],i[1]=-t[1],i[2]=-t[2],i[3]=-t[3],i[4]=-t[4],i[5]=-t[5],i[6]=-t[6],i[7]=-t[7],i[8]=-t[8],i[9]=-t[9],i[10]=-t[10],i[11]=-t[11],i[12]=-t[12],i[13]=-t[13],i[14]=-t[14],i[15]=-t[15],i},ortho:function(t,n,i,r,o,a,s){const u=s??new e(16);return u[0]=2/(n-t),u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2/(r-i),u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=1/(o-a),u[11]=0,u[12]=(n+t)/(t-n),u[13]=(r+i)/(i-r),u[14]=o/(o-a),u[15]=1,u},perspective:function(t,n,i,r,o){const a=o??new e(16),s=Math.tan(.5*Math.PI-.5*t);if(a[0]=s/n,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=s,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,Number.isFinite(r)){const e=1/(i-r);a[10]=r*e,a[14]=r*i*e}else a[10]=-1,a[14]=-i;return a},perspectiveReverseZ:function(t,n,i,r=1/0,o){const a=o??new e(16),s=1/Math.tan(.5*t);if(a[0]=s/n,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=s,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,r===1/0)a[10]=0,a[14]=i;else{const e=1/(r-i);a[10]=i*e,a[14]=r*i*e}return a},rotate:g,rotateX:function(t,n,i){const r=i??new e(16),o=t[4],a=t[5],s=t[6],u=t[7],c=t[8],l=t[9],f=t[10],d=t[11],h=Math.cos(n),_=Math.sin(n);return r[4]=h*o+_*c,r[5]=h*a+_*l,r[6]=h*s+_*f,r[7]=h*u+_*d,r[8]=h*c-_*o,r[9]=h*l-_*a,r[10]=h*f-_*s,r[11]=h*d-_*u,t!==r&&(r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r},rotateY:function(t,n,i){const r=i??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[8],l=t[9],f=t[10],d=t[11],h=Math.cos(n),_=Math.sin(n);return r[0]=h*o-_*c,r[1]=h*a-_*l,r[2]=h*s-_*f,r[3]=h*u-_*d,r[8]=h*c+_*o,r[9]=h*l+_*a,r[10]=h*f+_*s,r[11]=h*d+_*u,t!==r&&(r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=t[7],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r},rotateZ:function(t,n,i){const r=i??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[4],l=t[5],f=t[6],d=t[7],h=Math.cos(n),_=Math.sin(n);return r[0]=h*o+_*c,r[1]=h*a+_*l,r[2]=h*s+_*f,r[3]=h*u+_*d,r[4]=h*c-_*o,r[5]=h*l-_*a,r[6]=h*f-_*s,r[7]=h*d-_*u,t!==r&&(r[8]=t[8],r[9]=t[9],r[10]=t[10],r[11]=t[11],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r},rotation:p,rotationX:function(t,n){const i=n??new e(16),r=Math.cos(t),o=Math.sin(t);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=r,i[6]=o,i[7]=0,i[8]=0,i[9]=-o,i[10]=r,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},rotationY:function(t,n){const i=n??new e(16),r=Math.cos(t),o=Math.sin(t);return i[0]=r,i[1]=0,i[2]=-o,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=o,i[9]=0,i[10]=r,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},rotationZ:function(t,n){const i=n??new e(16),r=Math.cos(t),o=Math.sin(t);return i[0]=r,i[1]=o,i[2]=0,i[3]=0,i[4]=-o,i[5]=r,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},scale:function(t,n,i){const r=i??new e(16),o=n[0],a=n[1],s=n[2];return r[0]=o*t[0],r[1]=o*t[1],r[2]=o*t[2],r[3]=o*t[3],r[4]=a*t[4],r[5]=a*t[5],r[6]=a*t[6],r[7]=a*t[7],r[8]=s*t[8],r[9]=s*t[9],r[10]=s*t[10],r[11]=s*t[11],t!==r&&(r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r},scaling:function(t,n){const i=n??new e(16);return i[0]=t[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=t[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=t[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},set:function(t,n,i,r,o,a,s,u,c,l,f,d,h,_,m,p,g){const v=g??new e(16);return v[0]=t,v[1]=n,v[2]=i,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=u,v[8]=c,v[9]=l,v[10]=f,v[11]=d,v[12]=h,v[13]=_,v[14]=m,v[15]=p,v},setAxis:function(e,t,n,i){const o=i===e?i:r(e,i),a=4*n;return o[a+0]=t[0],o[a+1]=t[1],o[a+2]=t[2],o},setTranslation:function(e,t,n){const i=n??s();return e!==i&&(i[0]=e[0],i[1]=e[1],i[2]=e[2],i[3]=e[3],i[4]=e[4],i[5]=e[5],i[6]=e[6],i[7]=e[7],i[8]=e[8],i[9]=e[9],i[10]=e[10],i[11]=e[11]),i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},translate:function(t,n,i){const r=i??new e(16),o=n[0],a=n[1],s=n[2],u=t[0],c=t[1],l=t[2],f=t[3],d=t[4],h=t[5],_=t[6],m=t[7],p=t[8],g=t[9],v=t[10],y=t[11],b=t[12],x=t[13],w=t[14],M=t[15];return t!==r&&(r[0]=u,r[1]=c,r[2]=l,r[3]=f,r[4]=d,r[5]=h,r[6]=_,r[7]=m,r[8]=p,r[9]=g,r[10]=v,r[11]=y),r[12]=u*o+d*a+p*s+b,r[13]=c*o+h*a+g*s+x,r[14]=l*o+_*a+v*s+w,r[15]=f*o+m*a+y*s+M,r},translation:function(t,n){const i=n??new e(16);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=t[0],i[13]=t[1],i[14]=t[2],i[15]=1,i},transpose:function(t,n){const i=n??new e(16);if(i===t){let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,i}const r=t[0],o=t[1],a=t[2],s=t[3],u=t[4],c=t[5],l=t[6],f=t[7],d=t[8],h=t[9],_=t[10],m=t[11],p=t[12],g=t[13],v=t[14],y=t[15];return i[0]=r,i[1]=u,i[2]=d,i[3]=p,i[4]=o,i[5]=c,i[6]=h,i[7]=g,i[8]=a,i[9]=l,i[10]=_,i[11]=v,i[12]=s,i[13]=f,i[14]=m,i[15]=y,i},uniformScale:function(t,n,i){const r=i??new e(16);return r[0]=n*t[0],r[1]=n*t[1],r[2]=n*t[2],r[3]=n*t[3],r[4]=n*t[4],r[5]=n*t[5],r[6]=n*t[6],r[7]=n*t[7],r[8]=n*t[8],r[9]=n*t[9],r[10]=n*t[10],r[11]=n*t[11],t!==r&&(r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15]),r},uniformScaling:function(t,n){const i=n??new e(16);return i[0]=t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=t,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=t,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}}}(e),_.set(e,t)),t}const p=new Map;function g(e){let t=p.get(e);return t||(t=function(e){const t=f(e);function n(t,n,i,r){const o=new e(4);return void 0!==t&&(o[0]=t,void 0!==n&&(o[1]=n,void 0!==i&&(o[2]=i,void 0!==r&&(o[3]=r)))),o}const i=n;function r(t,n,i){const r=i??new e(4),o=.5*n,a=Math.sin(o);return r[0]=a*t[0],r[1]=a*t[1],r[2]=a*t[2],r[3]=Math.cos(o),r}function o(t,n,i){const r=i??new e(4),o=t[0],a=t[1],s=t[2],u=t[3],c=n[0],l=n[1],f=n[2],d=n[3];return r[0]=o*d+u*c+a*f-s*l,r[1]=a*d+u*l+s*c-o*f,r[2]=s*d+u*f+o*l-a*c,r[3]=u*d-o*c-a*l-s*f,r}const s=o;function u(t,n,i,r){const o=r??new e(4),s=t[0],u=t[1],c=t[2],l=t[3];let f,d,h=n[0],_=n[1],m=n[2],p=n[3],g=s*h+u*_+c*m+l*p;if(g<0&&(g=-g,h=-h,_=-_,m=-m,p=-p),1-g>a){const e=Math.acos(g),t=Math.sin(e);f=Math.sin((1-i)*e)/t,d=Math.sin(i*e)/t}else f=1-i,d=i;return o[0]=f*s+d*h,o[1]=f*u+d*_,o[2]=f*c+d*m,o[3]=f*l+d*p,o}function c(t,n){const i=n??new e(4);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i}const l=c;function d(t,n,i){const r=i??new e(4);return r[0]=t[0]-n[0],r[1]=t[1]-n[1],r[2]=t[2]-n[2],r[3]=t[3]-n[3],r}const h=d;function _(t,n,i){const r=i??new e(4);return r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r[3]=t[3]*n,r}const m=_;function p(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function g(e){const t=e[0],n=e[1],i=e[2],r=e[3];return Math.sqrt(t*t+n*n+i*i+r*r)}const v=g;function y(e){const t=e[0],n=e[1],i=e[2],r=e[3];return t*t+n*n+i*i+r*r}const b=y;function x(t,n){const i=n??new e(4),r=t[0],o=t[1],a=t[2],s=t[3],u=Math.sqrt(r*r+o*o+a*a+s*s);return u>1e-5?(i[0]=r/u,i[1]=o/u,i[2]=a/u,i[3]=s/u):(i[0]=0,i[1]=0,i[2]=0,i[3]=1),i}const w=t.create(),M=t.create(),P=t.create(),S=new e(4),B=new e(4);return{create:n,fromValues:i,set:function(t,n,i,r,o){const a=o??new e(4);return a[0]=t,a[1]=n,a[2]=i,a[3]=r,a},fromAxisAngle:r,toAxisAngle:function(e,n){const i=n??t.create(3),r=2*Math.acos(e[3]),o=Math.sin(.5*r);return o>a?(i[0]=e[0]/o,i[1]=e[1]/o,i[2]=e[2]/o):(i[0]=1,i[1]=0,i[2]=0),{angle:r,axis:i}},angle:function(e,t){const n=p(e,t);return Math.acos(2*n*n-1)},multiply:o,mul:s,rotateX:function(t,n,i){const r=i??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return r[0]=a*f+c*l,r[1]=s*f+u*l,r[2]=u*f-s*l,r[3]=c*f-a*l,r},rotateY:function(t,n,i){const r=i??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return r[0]=a*f-u*l,r[1]=s*f+c*l,r[2]=u*f+a*l,r[3]=c*f-s*l,r},rotateZ:function(t,n,i){const r=i??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return r[0]=a*f+s*l,r[1]=s*f-a*l,r[2]=u*f+c*l,r[3]=c*f-u*l,r},slerp:u,inverse:function(t,n){const i=n??new e(4),r=t[0],o=t[1],a=t[2],s=t[3],u=r*r+o*o+a*a+s*s,c=u?1/u:0;return i[0]=-r*c,i[1]=-o*c,i[2]=-a*c,i[3]=s*c,i},conjugate:function(t,n){const i=n??new e(4);return i[0]=-t[0],i[1]=-t[1],i[2]=-t[2],i[3]=t[3],i},fromMat:function(t,n){const i=n??new e(4),r=t[0]+t[5]+t[10];if(r>0){const e=Math.sqrt(r+1);i[3]=.5*e;const n=.5/e;i[0]=(t[6]-t[9])*n,i[1]=(t[8]-t[2])*n,i[2]=(t[1]-t[4])*n}else{let e=0;t[5]>t[0]&&(e=1),t[10]>t[4*e+e]&&(e=2);const n=(e+1)%3,r=(e+2)%3,o=Math.sqrt(t[4*e+e]-t[4*n+n]-t[4*r+r]+1);i[e]=.5*o;const a=.5/o;i[3]=(t[4*n+r]-t[4*r+n])*a,i[n]=(t[4*n+e]+t[4*e+n])*a,i[r]=(t[4*r+e]+t[4*e+r])*a}return i},fromEuler:function(t,n,i,r,o){const a=o??new e(4),s=.5*t,u=.5*n,c=.5*i,l=Math.sin(s),f=Math.cos(s),d=Math.sin(u),h=Math.cos(u),_=Math.sin(c),m=Math.cos(c);switch(r){case"xyz":a[0]=l*h*m+f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m-l*d*_;break;case"xzy":a[0]=l*h*m-f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m+l*d*_;break;case"yxz":a[0]=l*h*m+f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m+l*d*_;break;case"yzx":a[0]=l*h*m+f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m-l*d*_;break;case"zxy":a[0]=l*h*m-f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m-l*d*_;break;case"zyx":a[0]=l*h*m-f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m+l*d*_;break;default:throw new Error(`Unknown rotation order: ${r}`)}return a},copy:c,clone:l,add:function(t,n,i){const r=i??new e(4);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r[2]=t[2]+n[2],r[3]=t[3]+n[3],r},subtract:d,sub:h,mulScalar:_,scale:m,divScalar:function(t,n,i){const r=i??new e(4);return r[0]=t[0]/n,r[1]=t[1]/n,r[2]=t[2]/n,r[3]=t[3]/n,r},dot:p,lerp:function(t,n,i,r){const o=r??new e(4);return o[0]=t[0]+i*(n[0]-t[0]),o[1]=t[1]+i*(n[1]-t[1]),o[2]=t[2]+i*(n[2]-t[2]),o[3]=t[3]+i*(n[3]-t[3]),o},length:g,len:v,lengthSq:y,lenSq:b,normalize:x,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(t){const n=t??new e(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=1,n},rotationTo:function(n,i,o){const a=o??new e(4),s=t.dot(n,i);return s<-.999999?(t.cross(M,n,w),t.len(w)<1e-6&&t.cross(P,n,w),t.normalize(w,w),r(w,Math.PI,a),a):s>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(t.cross(n,i,w),a[0]=w[0],a[1]=w[1],a[2]=w[2],a[3]=1+s,x(a,a))},sqlerp:function(t,n,i,r,o,a){const s=a??new e(4);return u(t,r,o,S),u(n,i,o,B),u(S,B,2*o*(1-o),s),s}}}(e),p.set(e,t)),t}const v=new Map;function y(e){let t=v.get(e);return t||(t=function(e){function t(t,n,i,r){const o=new e(4);return void 0!==t&&(o[0]=t,void 0!==n&&(o[1]=n,void 0!==i&&(o[2]=i,void 0!==r&&(o[3]=r)))),o}function n(t,n,i){const r=i??new e(4);return r[0]=t[0]-n[0],r[1]=t[1]-n[1],r[2]=t[2]-n[2],r[3]=t[3]-n[3],r}function i(t,n,i,r){const o=r??new e(4);return o[0]=t[0]+i*(n[0]-t[0]),o[1]=t[1]+i*(n[1]-t[1]),o[2]=t[2]+i*(n[2]-t[2]),o[3]=t[3]+i*(n[3]-t[3]),o}function r(t,n,i){const r=i??new e(4);return r[0]=t[0]*n,r[1]=t[1]*n,r[2]=t[2]*n,r[3]=t[3]*n,r}function o(t,n){const i=n??new e(4);return i[0]=1/t[0],i[1]=1/t[1],i[2]=1/t[2],i[3]=1/t[3],i}function s(e){const t=e[0],n=e[1],i=e[2],r=e[3];return Math.sqrt(t*t+n*n+i*i+r*r)}function u(e){const t=e[0],n=e[1],i=e[2],r=e[3];return t*t+n*n+i*i+r*r}function c(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2],o=e[3]-t[3];return Math.sqrt(n*n+i*i+r*r+o*o)}function l(e,t){const n=e[0]-t[0],i=e[1]-t[1],r=e[2]-t[2],o=e[3]-t[3];return n*n+i*i+r*r+o*o}function f(t,n){const i=n??new e(4),r=t[0],o=t[1],a=t[2],s=t[3],u=Math.sqrt(r*r+o*o+a*a+s*s);return u>1e-5?(i[0]=r/u,i[1]=o/u,i[2]=a/u,i[3]=s/u):(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i}function d(t,n){const i=n??new e(4);return i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i}function h(t,n,i){const r=i??new e(4);return r[0]=t[0]*n[0],r[1]=t[1]*n[1],r[2]=t[2]*n[2],r[3]=t[3]*n[3],r}function _(t,n,i){const r=i??new e(4);return r[0]=t[0]/n[0],r[1]=t[1]/n[1],r[2]=t[2]/n[2],r[3]=t[3]/n[3],r}function m(t,n,i){const o=i??new e(4);return f(t,o),r(o,n,o)}return{create:t,fromValues:t,set:function(t,n,i,r,o){const a=o??new e(4);return a[0]=t,a[1]=n,a[2]=i,a[3]=r,a},ceil:function(t,n){const i=n??new e(4);return i[0]=Math.ceil(t[0]),i[1]=Math.ceil(t[1]),i[2]=Math.ceil(t[2]),i[3]=Math.ceil(t[3]),i},floor:function(t,n){const i=n??new e(4);return i[0]=Math.floor(t[0]),i[1]=Math.floor(t[1]),i[2]=Math.floor(t[2]),i[3]=Math.floor(t[3]),i},round:function(t,n){const i=n??new e(4);return i[0]=Math.round(t[0]),i[1]=Math.round(t[1]),i[2]=Math.round(t[2]),i[3]=Math.round(t[3]),i},clamp:function(t,n=0,i=1,r){const o=r??new e(4);return o[0]=Math.min(i,Math.max(n,t[0])),o[1]=Math.min(i,Math.max(n,t[1])),o[2]=Math.min(i,Math.max(n,t[2])),o[3]=Math.min(i,Math.max(n,t[3])),o},add:function(t,n,i){const r=i??new e(4);return r[0]=t[0]+n[0],r[1]=t[1]+n[1],r[2]=t[2]+n[2],r[3]=t[3]+n[3],r},addScaled:function(t,n,i,r){const o=r??new e(4);return o[0]=t[0]+n[0]*i,o[1]=t[1]+n[1]*i,o[2]=t[2]+n[2]*i,o[3]=t[3]+n[3]*i,o},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},lerp:i,lerpV:function(t,n,i,r){const o=r??new e(4);return o[0]=t[0]+i[0]*(n[0]-t[0]),o[1]=t[1]+i[1]*(n[1]-t[1]),o[2]=t[2]+i[2]*(n[2]-t[2]),o[3]=t[3]+i[3]*(n[3]-t[3]),o},max:function(t,n,i){const r=i??new e(4);return r[0]=Math.max(t[0],n[0]),r[1]=Math.max(t[1],n[1]),r[2]=Math.max(t[2],n[2]),r[3]=Math.max(t[3],n[3]),r},min:function(t,n,i){const r=i??new e(4);return r[0]=Math.min(t[0],n[0]),r[1]=Math.min(t[1],n[1]),r[2]=Math.min(t[2],n[2]),r[3]=Math.min(t[3],n[3]),r},mulScalar:r,scale:r,divScalar:function(t,n,i){const r=i??new e(4);return r[0]=t[0]/n,r[1]=t[1]/n,r[2]=t[2]/n,r[3]=t[3]/n,r},inverse:o,invert:o,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},length:s,len:s,lengthSq:u,lenSq:u,distance:c,dist:c,distanceSq:l,distSq:l,normalize:f,negate:function(t,n){const i=n??new e(4);return i[0]=-t[0],i[1]=-t[1],i[2]=-t[2],i[3]=-t[3],i},copy:d,clone:d,multiply:h,mul:h,divide:_,div:_,zero:function(t){const n=t??new e(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=0,n},transformMat4:function(t,n,i){const r=i??new e(4),o=t[0],a=t[1],s=t[2],u=t[3];return r[0]=n[0]*o+n[4]*a+n[8]*s+n[12]*u,r[1]=n[1]*o+n[5]*a+n[9]*s+n[13]*u,r[2]=n[2]*o+n[6]*a+n[10]*s+n[14]*u,r[3]=n[3]*o+n[7]*a+n[11]*s+n[15]*u,r},setLength:m,truncate:function(t,n,i){const r=i??new e(4);return s(t)>n?m(t,n,r):d(t,r)},midpoint:function(t,n,r){return i(t,n,.5,r??new e(4))}}}(e),v.set(e,t)),t}function b(e,t,n,i,r,o){return{mat3:h(e),mat4:m(t),quat:g(n),vec2:c(i),vec3:f(r),vec4:y(o)}}const{mat3:x,mat4:w,quat:M,vec2:P,vec3:S,vec4:B}=b(Float32Array,Float32Array,Float32Array,Float32Array,Float32Array,Float32Array),{mat3:D,mat4:C,quat:U,vec2:z,vec3:O,vec4:G}=b(Float64Array,Float64Array,Float64Array,Float64Array,Float64Array,Float64Array),{mat3:A,mat4:T,quat:I,vec2:V,vec3:j,vec4:F}=b(i,Array,Array,Array,Array,Array)},722:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Geometry=t.BigTriangle=t.CubeGeometry=void 0;var i=n(161);Object.defineProperty(t,"CubeGeometry",{enumerable:!0,get:function(){return i.CubeGeometry}});var r=n(657);Object.defineProperty(t,"BigTriangle",{enumerable:!0,get:function(){return r.BigTriangle}});var o=n(80);Object.defineProperty(t,"Geometry",{enumerable:!0,get:function(){return o.Geometry}})},760:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UVMaterial=t.ShaderMaterial=t.BasicMaterial=t.Material=void 0;var i=n(35);Object.defineProperty(t,"Material",{enumerable:!0,get:function(){return i.Material}});var r=n(838);Object.defineProperty(t,"BasicMaterial",{enumerable:!0,get:function(){return r.BasicMaterial}});var o=n(941);Object.defineProperty(t,"ShaderMaterial",{enumerable:!0,get:function(){return o.ShaderMaterial}});var a=n(331);Object.defineProperty(t,"UVMaterial",{enumerable:!0,get:function(){return a.UVMaterial}})},779:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OrthographicCamera=void 0;const i=n(717),r=n(534);class o extends r.Camera{constructor({left:e=-1,right:t=1,bottom:n=-1,top:r=1,near:o=.1,far:a=1e3,position:s=i.vec3.create(0,0,10),target:u=i.vec3.create(0,0,0),up:c=i.vec3.create(0,1,0)}={}){super(),this.left=e,this.right=t,this.bottom=n,this.top=r,this.near=o,this.far=a,this.position=i.vec3.clone(s),this.target=i.vec3.clone(u),this.up=i.vec3.clone(c)}updateProjectionMatrix(){console.log("Updating Orthographic Projection Matrix"),this._projectionMatrix=i.mat4.ortho(this.left,this.right,this.bottom,this.top,this.near,this.far),this._isProjectionDirty=!1}updateViewMatrix(){console.log("Updating Orthographic View Matrix"),this._viewMatrix=i.mat4.lookAt(this.position,this.target,this.up),this._isViewDirty=!1}setPosition(e,t,n){super.setPosition(e,t,n);const r=i.vec3.create(e,t,n);i.vec3.equals(this.position,r)||(this.position=i.vec3.copy(r,this.position),this._isViewDirty=!0)}setTarget(e){i.vec3.equals(this.target,e)||(this.target=i.vec3.copy(e,this.target),this._isViewDirty=!0)}setUp(e){i.vec3.equals(this.up,e)||(this.up=i.vec3.copy(e,this.up),this._isViewDirty=!0)}setLeft(e){this.left!==e&&(this.left=e,this._isProjectionDirty=!0)}setRight(e){this.right!==e&&(this.right=e,this._isProjectionDirty=!0)}setBottom(e){this.bottom!==e&&(this.bottom=e,this._isProjectionDirty=!0)}setTop(e){this.top!==e&&(this.top=e,this._isProjectionDirty=!0)}setNear(e){this.near!==e&&(this.near=e,this._isProjectionDirty=!0)}setFar(e){this.far!==e&&(this.far=e,this._isProjectionDirty=!0)}viewportResized(e){}}t.OrthographicCamera=o},819:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read_write> grid_mass_atomic: array<atomic<i32>>;\n@group(0) @binding(2) var<storage, read_write> grid_momentum_atomic: array<atomic<i32>>;\n@group(0) @binding(3) var<storage, read> particles_in: array<Particle>;\n@group(0) @binding(4) var<storage, read_write> particles_out: array<Particle>;\n\n@compute @workgroup_size(64) // Or your preferred workgroup size\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n    if (id.x >= params.num_particles) {\n        return;\n    }\n\n    let p = particles_in[id.x];\n\n    // 1. Calculate particle position in grid units and base cell for APIC stencil\n    let particle_pos_grid_units = p.position * params.inv_dx;\n    // cellIndex_base_int is the integer grid cell index for the center of the 3x3x3 stencil\n    let cellIndex_base_float = particle_pos_grid_units - 0.5;\n    let cellIndex_base_int = vec3<i32>(floor(cellIndex_base_float));\n    // cellDiff_from_base_center is particle's sub-grid pos relative to the center of cellIndex_base_int's cell\n    let cellDiff_from_base_center = cellIndex_base_float - vec3<f32>(cellIndex_base_int);\n\n    // 2. Calculate 1D B-spline weights for the 3 stencil nodes in each dimension\n    //    relative to cellIndex_base_int\n    var bspline_weights_1D: array<vec3<f32>, 3>; // [dim_idx][offset_idx from center: -1, 0, +1]\n    for (var d = 0u; d < 3u; d = d + 1u) {\n        let u_particle_offset = cellDiff_from_base_center[d];\n        bspline_weights_1D[d][0] = quadratic_bspline_N(u_particle_offset + 1.0); // Stencil offset -1\n        bspline_weights_1D[d][1] = quadratic_bspline_N(u_particle_offset);       // Stencil offset  0\n        bspline_weights_1D[d][2] = quadratic_bspline_N(u_particle_offset - 1.0); // Stencil offset +1\n    }\n\n    // 3. Iterate over 3x3x3 stencil\n    for (var gx_offset_idx = 0u; gx_offset_idx < 3u; gx_offset_idx = gx_offset_idx + 1u) {\n        for (var gy_offset_idx = 0u; gy_offset_idx < 3u; gy_offset_idx = gy_offset_idx + 1u) {\n            for (var gz_offset_idx = 0u; gz_offset_idx < 3u; gz_offset_idx = gz_offset_idx + 1u) {\n                \n                let final_weight = bspline_weights_1D[0][gx_offset_idx] *\n                                   bspline_weights_1D[1][gy_offset_idx] *\n                                   bspline_weights_1D[2][gz_offset_idx];\n\n                if (final_weight == 0.0) { continue; }\n\n                let target_grid_node_abs_idx = cellIndex_base_int +\n                                               vec3<i32>(i32(gx_offset_idx), i32(gy_offset_idx), i32(gz_offset_idx)) -\n                                               vec3<i32>(1, 1, 1);\n\n                // Boundary check for target_grid_node_abs_idx\n                if (target_grid_node_abs_idx.x < 0 || target_grid_node_abs_idx.x >= i32(params.grid_size) ||\n                    target_grid_node_abs_idx.y < 0 || target_grid_node_abs_idx.y >= i32(params.grid_size) ||\n                    target_grid_node_abs_idx.z < 0 || target_grid_node_abs_idx.z >= i32(params.grid_size)) {\n                    continue;\n                }\n                \n                let flat_target_idx = grid_idx_flat(target_grid_node_abs_idx, params.grid_size);\n                \n                // Calculate APIC momentum term contribution\n                // cellDist_world is vector from particle to current grid node's center (world units)\n                let grid_node_world_pos = (vec3<f32>(target_grid_node_abs_idx) + 0.5) * params.dx;\n                let cellDist_world = grid_node_world_pos - p.position;\n                let Q_affine_correction = p.affine_matrix_C * cellDist_world;\n\n                // Contributions\n                let mass_contrib = final_weight * p.mass;\n                let momentum_contrib_vec = final_weight * (p.mass * p.velocity + Q_affine_correction);\n\n                // Atomic adds\n                atomicAdd(&grid_mass_atomic[flat_target_idx], encodeFixedPoint(mass_contrib));\n                \n                let mom_x_idx = flat_target_idx * 3u + 0u;\n                let mom_y_idx = flat_target_idx * 3u + 1u;\n                let mom_z_idx = flat_target_idx * 3u + 2u;\n\n                atomicAdd(&grid_momentum_atomic[mom_x_idx], encodeFixedPoint(momentum_contrib_vec.x));\n                atomicAdd(&grid_momentum_atomic[mom_y_idx], encodeFixedPoint(momentum_contrib_vec.y));\n                atomicAdd(&grid_momentum_atomic[mom_z_idx], encodeFixedPoint(momentum_contrib_vec.z));\n            }\n        }\n    }\n\n    particles_out[id.x] = p;\n}\n"},838:function(e,t,n){var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.BasicMaterial=void 0;const r=n(710),o=n(330),a=n(35),s=n(343),u=i(n(414)),c=i(n(43));class l extends a.Material{constructor(e,t={}){l.precompile(e),super(new s.UniformManager(e,{uniforms:[{name:"color",value:t.color||new r.Color(1,1,1)}],textures:[{texture:t.map||o.DefaultTexture.instance,dimension:"2d",accessType:"sample"}],label:"BasicMaterial"}))}get cacheKey(){return"basic-material"}get shaderCode(){return l.shaderModule}static precompile(e){l.shaderModule||(l.shaderModule=e.createShaderModule({label:"basic-material-shader",code:`\n${u.default}\n${c.default}\n`}))}}t.BasicMaterial=l,l.shaderModule=null},861:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read> grid_velocity_in: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read> particles_in: array<Particle>;\n@group(0) @binding(3) var<storage, read_write> particles_out: array<Particle>;\n\n//--------------------------------------------------------------------------------------\n// Main Compute Shader\n//--------------------------------------------------------------------------------------\n@compute @workgroup_size(64, 1, 1) // Example workgroup size\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n    if (id.x >= params.num_particles) {\n        return;\n    }\n\n    let p_in = particles_in[id.x];\n    var p_out = p_in; // Initialize output particle with input values\n\n    // 1. Calculate particle position in grid units and base cell for APIC stencil\n    let particle_pos_grid_units = p_in.position * params.inv_dx;\n    // cellIndex_base_int is the integer grid cell index for the center of the 3x3x3 stencil\n    let cellIndex_base_float = particle_pos_grid_units - 0.5;\n    let cellIndex_base_int = vec3<i32>(floor(cellIndex_base_float));\n    // cellDiff_from_base_center is particle's sub-grid pos relative to the center of cellIndex_base_int's cell\n    let cellDiff_from_base_center = cellIndex_base_float - vec3<f32>(cellIndex_base_int);\n\n    // 2. Calculate 1D B-spline weights (same as in P2G)\n    var bspline_weights_1D: array<vec3<f32>, 3>; // [dim_idx][offset_idx from center: -1, 0, +1]\n    for (var d = 0u; d < 3u; d = d + 1u) {\n        let u_particle_offset = cellDiff_from_base_center[d];\n        bspline_weights_1D[d][0] = quadratic_bspline_N(u_particle_offset + 1.0); // Stencil offset -1\n        bspline_weights_1D[d][1] = quadratic_bspline_N(u_particle_offset);       // Stencil offset  0\n        bspline_weights_1D[d][2] = quadratic_bspline_N(u_particle_offset - 1.0); // Stencil offset +1\n    }\n\n    var new_particle_velocity = vec3<f32>(0.0, 0.0, 0.0);\n    var new_particle_C = mat3x3<f32>(); // Zero matrix\n\n    // 3. Iterate over 3x3x3 stencil to interpolate velocity and C matrix\n    for (var gx_offset_idx = 0u; gx_offset_idx < 3u; gx_offset_idx = gx_offset_idx + 1u) {\n        for (var gy_offset_idx = 0u; gy_offset_idx < 3u; gy_offset_idx = gy_offset_idx + 1u) {\n            for (var gz_offset_idx = 0u; gz_offset_idx < 3u; gz_offset_idx = gz_offset_idx + 1u) {\n                \n                let final_weight = bspline_weights_1D[0][gx_offset_idx] *\n                                   bspline_weights_1D[1][gy_offset_idx] *\n                                   bspline_weights_1D[2][gz_offset_idx];\n\n                if (final_weight == 0.0) { continue; }\n\n                let target_grid_node_abs_idx = cellIndex_base_int +\n                                               vec3<i32>(i32(gx_offset_idx), i32(gy_offset_idx), i32(gz_offset_idx)) -\n                                               vec3<i32>(1, 1, 1); // Absolute grid indices\n\n                // For G2P, we read from grid. Boundary handling for reads is often done by clamping\n                // indices in the grid_idx_flat function or ensuring particles don't get too close.\n                // The grid_idx_flat above includes clamping.\n                let flat_target_idx = grid_idx_flat_clamp(target_grid_node_abs_idx, params.grid_size);\n                let grid_node_vel = grid_velocity_in[flat_target_idx];\n\n                // Interpolate particle velocity\n                new_particle_velocity = new_particle_velocity + final_weight * grid_node_vel;\n\n                // Interpolate C matrix (APIC)\n                // dist_grid_node_to_particle_world is vector from grid node center to particle (world units)\n                let grid_node_world_pos = (vec3<f32>(target_grid_node_abs_idx) + 0.5) * params.dx;\n                let dist_grid_node_to_particle_world = p_in.position - grid_node_world_pos;\n                \n                // Original MLS-MPM/APIC C update: C += 4 * inv_dx^2 * weight * vel_grid * (pos_grid - pos_particle)_world\n                // The factor inv_dx^2 is often because C itself represents dv/dx, and dpos is dx.\n                // Python: new_C += 4 * inv_dx * weight * g_v.outer_product(dpos) where dpos is (offset_float - fx_norm)\n                // (offset_float - fx_norm) is like (grid_node_rel_to_base - particle_pos_rel_to_base)\n                // = (grid_node_abs - particle_pos_abs) in grid units\n                // So dpos_grid_units = vec3<f32>(target_grid_node_abs_idx) - particle_pos_grid_units\n                let dpos_grid_units = vec3<f32>(target_grid_node_abs_idx) - particle_pos_grid_units;\n\n                let term_outer_product = calculate_outer_product(grid_node_vel, dpos_grid_units);\n                new_particle_C = new_particle_C + ( (4.0 * params.inv_dx) * final_weight) * term_outer_product;\n            }\n        }\n    }\n\n    // 4. Update particle state\n    p_out.velocity = new_particle_velocity;\n    p_out.affine_matrix_C = new_particle_C;\n\n    // Update Jf (elastic volume determinant) - as in mls_mpm.py G2P\n    // Jf[p] *= 1 + dt * new_C.trace()\n    let trace_C = new_particle_C[0][0] + new_particle_C[1][1] + new_particle_C[2][2];\n    p_out.Jf = p_in.Jf * (1.0 + params.dt * trace_C);\n\n    // Advect particle position (using new velocity)\n    p_out.position = p_in.position + new_particle_velocity * params.dt;\n    \n    // F and Jp were updated in P2G. Mass and material_idx are unchanged.\n    particles_out[id.x] = p_out;\n}\n\nfn calculate_outer_product(a: vec3<f32>, b: vec3<f32>) -> mat3x3<f32> {\n    let col0 = a * b.x;\n    let col1 = a * b.y;\n    let col2 = a * b.z;\n    return mat3x3<f32>(col0, col1, col2);\n}\n"},898:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeTask=void 0;const i=n(717),r=n(343);t.ComputeTask=class{constructor(e,t){this._options=t,this._uniformManager=new r.UniformManager(e,{uniformVisibility:GPUShaderStage.COMPUTE,buffers:this._options.buffers,textures:this._options.textures,samplers:this._options.samplers})}get cacheKey(){return`ComputeTask:${this.label}:${this._uniformManager.cacheKey}`}get shaderModule(){return this._options.shader}get label(){return this._options.label||"Compute Task"}get dispatchCount(){return this._options.dispatchCount||i.vec3.create(8,8,1)}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}get entryPoint(){return this._options.entryPoint}}},941:function(e,t,n){var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.ShaderMaterial=void 0;const r=n(35),o=n(343),a=i(n(414));class s extends r.Material{constructor(e,t){super(new o.UniformManager(e,{uniforms:t.uniforms,textures:t.textures,buffers:t.buffers,label:"ShaderMaterial"})),this._options=t,this.compile(e)}compile(e){this._shaderModule=e.createShaderModule({label:"ShaderModule",code:`\n${a.default}\n${this._options.code}\n      `})}get cacheKey(){return this._uniformManager.cacheKey+"-"+btoa(this._options.code)}get shaderCode(){return this._shaderModule}}t.ShaderMaterial=s},950:(e,t,n)=>{n.r(t),n.d(t,{default:()=>i});const i="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read_write> grid_mass_in: array<atomic<i32>>;     // Read the atomically summed mass\n@group(0) @binding(2) var<storage, read_write> grid_momentum_in: array<atomic<i32>>; // Read the atomically summed momentum (flat)\n@group(0) @binding(3) var<storage, read_write> grid_velocity_out: array<vec3<f32>>; // Write final f32 velocities\n\n//--------------------------------------------------------------------------------------\n// Main Compute Shader\n//--------------------------------------------------------------------------------------\n@compute @workgroup_size(4, 4, 4) // Example 3D workgroup size, total 512. Adjust as needed.\n                                 // Dispatch would be ceil(grid_size/8) in each dimension.\nfn main(@builtin(global_invocation_id) grid_coords_abs_u32: vec3<u32>) {\n    // grid_coords_abs_u32 are the absolute 3D integer coordinates of the current grid cell\n\n    if (grid_coords_abs_u32.x >= params.grid_size ||\n        grid_coords_abs_u32.y >= params.grid_size ||\n        grid_coords_abs_u32.z >= params.grid_size) {\n        return; // Out of bounds for the grid\n    }\n\n    // Convert 3D grid coords to 1D flat index for accessing input buffers\n    let flat_idx = grid_coords_abs_u32.x * params.grid_size * params.grid_size +\n                   grid_coords_abs_u32.y * params.grid_size +\n                   grid_coords_abs_u32.z;\n\n    if (flat_idx == 0u) { // Test for the first grid cell\n        let test_float: f32 = 1.23;\n        let encoded_test: i32 = encodeFixedPoint(test_float); // Uses FIXED_POINT_MULTIPLIER from structs.wgsl\n        let decoded_test: f32 = decodeFixedPoint(encoded_test);\n        grid_velocity_out[flat_idx] = vec3<f32>(f32(encoded_test), decoded_test, test_float);\n        return; // Only process this one cell for this test\n    }\n\n    // 1. Decode mass\n    // atomicLoad is not strictly necessary if Stage 1 P2G is guaranteed to finish before this.\n    // We can treat them as regular i32 after the P2G pass.\n    // For clarity of intent (that these were atomically written):\n    let mass_fixedpoint = atomicLoad(&grid_mass_in[flat_idx]);\n    let mass_float = 1.0; //decodeFixedPoint(mass_fixedpoint);\n\n    var final_velocity = vec3<f32>(0.0, 0.0, 0.0);\n\n    if (mass_float > 1e-9) { // Or some other small epsilon to avoid division by zero\n        // 2. Decode momentum\n        let mom_x_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 0u]);\n        let mom_y_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 1u]);\n        let mom_z_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 2u]);\n\n        var momentum_float = vec3<f32>(\n            decodeFixedPoint(mom_x_fixedpoint),\n            decodeFixedPoint(mom_y_fixedpoint),\n            decodeFixedPoint(mom_z_fixedpoint)\n        );\n\n        // 3. Normalize to get velocity\n        final_velocity = momentum_float / mass_float;\n\n        // final_velocity.y = final_velocity.y - 9.8 * 0.0001;\n\n        // 4. Apply Gravity\n        final_velocity.y = final_velocity.y - params.gravity * params.dt;\n\n        // 5. Apply Boundary Conditions\n        // Using grid_coords_abs_u32 (which are 0 to grid_size-1)\n        let boundary_min = f32(params.boundary_extent);\n        let boundary_max = f32(params.grid_size) - f32(params.boundary_extent) -1.0; // -1 because grid_coords are 0-indexed\n\n        // X-axis boundaries\n        // if (f32(grid_coords_abs_u32.x) < boundary_min && final_velocity.x < 0.0) {\n        //     final_velocity.x = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.x) > boundary_max && final_velocity.x > 0.0) {\n        //     final_velocity.x = 0.0;\n        // }\n\n        // // Y-axis boundaries\n        // if (f32(grid_coords_abs_u32.y) < boundary_min && final_velocity.y < 0.0) {\n        //     final_velocity.y = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.y) > boundary_max && final_velocity.y > 0.0) {\n        //     // Example: Sticky top boundary or just reflect/zero\n        //     final_velocity.y = 0.0;\n        // }\n\n        // // Z-axis boundaries\n        // if (f32(grid_coords_abs_u32.z) < boundary_min && final_velocity.z < 0.0) {\n        //     final_velocity.z = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.z) > boundary_max && final_velocity.z > 0.0) {\n        //     final_velocity.z = 0.0;\n        // }\n    }\n    // Else (mass is zero), final_velocity remains (0,0,0)\n\n    // 6. Write to output velocity buffer\n    grid_velocity_out[flat_idx] = final_velocity;\n}"}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var o=t[i]={exports:{}};return e[i].call(o.exports,o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(325)})()));