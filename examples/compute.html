<!doctype html>
<html>
    <head>
        <title>tinygpu example: Invert an image in a compute shader</title>
        <style type="text/css">
            body {
                margin: 0;
                overflow: hidden;
            }

            canvas {
                display: block;
                position: absolute;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
            }
        </style>
    </head>

    <body>
        <canvas id="canvas"></canvas>
        <script src="../dist/index.js"></script>
        <script>
            document.addEventListener("DOMContentLoaded", async () => {
                const canvas = document.getElementById("canvas");
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;

                const renderer = new tinygpu.Renderer({ canvas });
                await renderer.init();

                const scene = renderer.createScene();
                const camera = renderer.createOrthographicCamera();

                const tex = await renderer.loadImageTexture(
                    "./matthew-stephenson-8VvxbqE8ZX0-unsplash.jpg",
                );

                const target = renderer.createTexture({
                    size: { width: tex.width, height: tex.height },
                    format: "rgba8unorm",
                    usage:
                        GPUTextureUsage.TEXTURE_BINDING |
                        GPUTextureUsage.COPY_DST |
                        GPUTextureUsage.RENDER_ATTACHMENT |
                        GPUTextureUsage.STORAGE_BINDING,
                });

                const shader = renderer.createShaderModule({
                    code: /* wgsl */ `

@group(0) @binding(0) var aSampler: sampler;
@group(0) @binding(1) var inputTexture: texture_2d<f32>;
@group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(16, 16, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let textureDims = textureDimensions(inputTexture);

    if (global_id.x >= textureDims.x || global_id.y >= textureDims.y) {
        return; // Out of bounds check
    }

    let uv = vec2<f32>(global_id.xy) / vec2<f32>(textureDims);
    let texelCoords = vec2<i32>(global_id.xy);
    let color = textureSampleLevel(inputTexture, aSampler, uv, 0);

    // Example: Invert color
    let newcol = vec3(1.0) - color.rgb;

    textureStore(outputTexture, texelCoords, vec4(newcol, 1.0));
}

                  `
                });

                // @workgroup_size(16, 16, 1) in shader above
                const dispatchCount = [
                    Math.ceil(tex.width / 16),
                    Math.ceil(tex.height / 16),
                    1
                ];

                const task = renderer.createComputeTask({
                    shader,
                    dispatchCount,
                    samplers: [{
                        visibility: GPUShaderStage.COMPUTE,
                        type: "filtering",
                        sampler: renderer.createSampler({
                            magFilter: "linear",
                            minFilter: "linear",
                        })
                    }],
                    textures: [
                        {
                            visibility: GPUShaderStage.COMPUTE,
                            accessType: "sample",
                            texture: tex,
                        },
                        {
                            visibility: GPUShaderStage.COMPUTE,
                            accessType: "write-only",
                            texture: target,
                        },
                    ],
                });

                const geo = renderer.createGeometry(
                    tinygpu.geometry.BigTriangle,
                );
                const mat = renderer.createMaterial(
                    tinygpu.material.BasicMaterial,
                    {
                        map: target,
                    },
                );
                const mesh = renderer.createMesh(geo, mat);

                scene.add(mesh);

                renderer.compute([task]);
                renderer.render(scene, camera);
            });
        </script>
    </body>
</html>
