!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("tinygpu",[],t):"object"==typeof exports?exports.tinygpu=t():e.tinygpu=t()}(self,(()=>(()=>{"use strict";var e={35:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Material=void 0,t.Material=class{constructor(e){this._uniformManager=e}get bindGroupLayout(){var e;return null===(e=this._uniformManager)||void 0===e?void 0:e.bindGroupLayout}get bindGroup(){var e;return null===(e=this._uniformManager)||void 0===e?void 0:e.bindGroup}updateUniform(e){this._uniformManager.updateUniform(e)}update(){var e;null===(e=this._uniformManager)||void 0===e||e.update()}}},41:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Scene=void 0;const r=n(541),i=n(717),o=n(343),a=n(435),s=n(997);class u extends r.Transform{constructor(e){super(),this._lightManager=new s.LightManager(e),this._uniformManager=new o.UniformManager(e.device,{uniforms:[{name:"projection matrix",value:i.mat4.create()},{name:"view matrix",value:i.mat4.create()},{name:"camera position",value:i.vec3.create()},{name:"resolution",value:i.vec2.create(1,1)},{name:"time",value:performance.now()/1e3},{name:"numLights",value:this._lightManager.numLights,type:"u32"}],buffers:[{buffer:this._lightManager.buffer,type:"read-only-storage",visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}]})}update(e,t){this.updateLights(),this._uniformManager.updateUniform({name:"projection matrix",value:e.projectionMatrix}),this._uniformManager.updateUniform({name:"view matrix",value:e.viewMatrix}),this._uniformManager.updateUniform({name:"camera position",value:e.position}),this._uniformManager.updateUniform({name:"resolution",value:t}),this._uniformManager.updateUniform({name:"time",value:performance.now()/1e3}),this._uniformManager.updateUniform({name:"numLights",value:this._lightManager.numLights}),this._uniformManager.update()}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}updateLights(){this.traverse((e=>{e instanceof a.Light&&this._lightManager.addLight(e)})),this._lightManager.clean()}}t.Scene=u},43:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="struct Uniforms {\n  color: vec4<f32>\n}\n\n@group(BG_UNIFORMS) @binding(0) var<uniform> uniforms: Uniforms;\n@group(BG_UNIFORMS) @binding(1) var tex_sampler: sampler;\n@group(BG_UNIFORMS) @binding(2) var tex_map: texture_2d<f32>;\n\nstruct VSOut {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs_main(in: VSIn) -> VSOut {\n  let modelViewProj: mat4x4<f32> = scene_uniforms.projection * scene_uniforms.view * model_uniforms.model;\n\n  let vs_out: VSOut = VSOut(\n    modelViewProj * vec4<f32>(in.position, 1.0),\n    in.uv,\n  );\n  return vs_out;\n}\n\n@fragment\nfn fs_main(vs_out: VSOut) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(tex_map, tex_sampler, vs_out.uv);\n  return color * uniforms.color;\n}\n"},80:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Geometry=void 0,t.Geometry=class{constructor(e,t,n,r,i){this._renderer=e,this._vertexBuffer=t,this._indexBuffer=n,this._indexCount=r,this._vertexCount=i}get device(){return this._renderer.device}get vertexBuffer(){return this._vertexBuffer}get indexBuffer(){return this._indexBuffer}get indexCount(){return this._indexCount}get vertexCount(){return this._vertexCount}get uvBuffer(){return this._uvBuffer}}},108:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Mesh=void 0;const r=n(717),i=n(541),o=n(343);class a extends i.Transform{constructor(e,t,n,i=1,a){super(),this._device=e,this.material=t,this.geometry=n,this._instances=i,this._normalMatrix=r.mat3.identity(),this.updateNormalMatrix(),this._uniformManager=new o.UniformManager(e,{uniforms:[{name:"model",value:this.worldMatrix},{name:"normalMatrix",value:this._normalMatrix}],buffers:a||[],label:"Mesh"})}get cacheKey(){return`${this.geometry.cacheKey}-${this.material.cacheKey}-${this._uniformManager.cacheKey}`}update(){this.material.update(),this.updateNormalMatrix(),this._uniformManager.updateUniform({name:"model",value:this.worldMatrix}),this._uniformManager.updateUniform({name:"normalMatrix",value:this._normalMatrix}),this._uniformManager.update()}updateNormalMatrix(){r.mat3.fromMat4(this.worldMatrix,this._normalMatrix),r.mat3.invert(this._normalMatrix,this._normalMatrix),r.mat3.transpose(this._normalMatrix,this._normalMatrix)}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}get bufferLayout(){return this.geometry.bufferLayout}get buffers(){return this._uniformManager.buffers}get instanceCount(){return this._instances}}t.Mesh=a},149:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OrthographicCamera=t.PerspectiveCamera=t.Camera=void 0;var r=n(534);Object.defineProperty(t,"Camera",{enumerable:!0,get:function(){return r.Camera}});var i=n(599);Object.defineProperty(t,"PerspectiveCamera",{enumerable:!0,get:function(){return i.PerspectiveCamera}});var o=n(779);Object.defineProperty(t,"OrthographicCamera",{enumerable:!0,get:function(){return o.OrthographicCamera}})},157:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="// blinn_phong_material.wgsl\n// Assumes header.wgsl is prepended or included.\n\n//--------------------------------------------------------------------\n// Structs already defined in header.wgsl:\n//   SceneUniforms, ModelUniforms, VSIn\n//--------------------------------------------------------------------\n\n//--------------------------------------------------------------------\n// Light structure (as defined in your light.ts)\n//--------------------------------------------------------------------\nstruct ShaderLight {\n    matrix: mat4x4<f32>,      // Light's world matrix\n    attenuation: vec3<f32>,   // x: const, y: lin, z: quad\n    color: vec4<f32>,\n    intensity: f32,\n    range: f32,\n    lightType: u32,           // 0: Ambient, 1: Point (consistent with LightType enum)\n    enabled: u32,             // 1 if enabled, 0 if not\n    radius: f32,\n};\n\n//--------------------------------------------------------------------\n// Bindings already established in header.wgsl for BG_SCENE and BG_MODEL\n// @group(BG_SCENE) @binding(0) var<uniform> scene_uniforms: SceneUniforms;\n// @group(BG_MODEL) @binding(0) var<uniform> model_uniforms: ModelUniforms;\n//\n// We need to ensure SceneUniforms in header.wgsl also includes numLights\n// and ModelUniforms includes normal_matrix.\n//\n// Example modifications to header.wgsl structs (if not already done):\n//\n// struct SceneUniforms {\n//   projection: mat4x4<f32>,\n//   view: mat4x4<f32>,\n//   camera_position: vec3<f32>,\n//   resolution: vec2<f32>,\n//   time: f32,\n//   numLights: u32, // ADD THIS if not present\n// }\n//\n// struct ModelUniforms {\n//   model: mat4x4<f32>,\n//   normalMatrix: mat3x3<f32>, // ADD THIS (use 'normalMatrix' to match Mesh.ts better)\n// }\n//--------------------------------------------------------------------\n\n\n//--------------------------------------------------------------------\n// Lights Array (Storage Buffer)\n// This comes from Scene's UniformManager, which is bound to BG_SCENE (Group 0)\n// The binding index should be 1, assuming the UBO for SceneUniforms is 0.\n// This matches Scene.ts: constructor -> _uniformManager -> buffers: [ { buffer: lightManager.buffer ...} ]\n// Your UniformManager.ts places 'uniforms' (UBO) at binding 0, then samplers, then textures, then 'buffers' (Storage).\n// So if there are no samplers/textures in the Scene's UniformManager, lights buffer is at binding 1.\n//--------------------------------------------------------------------\n@group(BG_SCENE) @binding(1) var<storage, read> lights_array: array<ShaderLight>;\n\n\n//--------------------------------------------------------------------\n// Material-Specific Uniforms for Blinn-Phong (BG_UNIFORMS - Group 2)\n//--------------------------------------------------------------------\nstruct BlinnPhongMaterialParams {\n  ambient_color: vec3<f32>,   // Ka\n  diffuse_color: vec3<f32>,   // Kd - base color of the surface\n  specular_color: vec3<f32>,  // Ks - color of the highlight\n  shininess: f32,             // Alpha - controls highlight size/sharpness\n};\n\n@group(BG_UNIFORMS) @binding(0) var<uniform> material_params: BlinnPhongMaterialParams;\n// Optional: Texture for diffuse color\n// @group(BG_UNIFORMS) @binding(1) var material_sampler: sampler;\n// @group(BG_UNIFORMS) @binding(2) var diffuse_texture: texture_2d<f32>;\n\n//--------------------------------------------------------------------\n// Vertex Shader Output (VSOut)\n//--------------------------------------------------------------------\nstruct VSOut {\n    @builtin(position) clip_position: vec4<f32>,\n    @location(0) world_position: vec3<f32>,\n    @location(1) world_normal: vec3<f32>,\n    @location(2) uv: vec2<f32>,\n};\n\n//--------------------------------------------------------------------\n// Vertex Shader (vs_main)\n//--------------------------------------------------------------------\n@vertex\nfn vs_main(in: VSIn) -> VSOut {\n    var vs_out: VSOut;\n\n    let world_pos_vec4 = model_uniforms.model * vec4<f32>(in.position, 1.0);\n    vs_out.world_position = world_pos_vec4.xyz;\n    vs_out.clip_position = scene_uniforms.projection * scene_uniforms.view * world_pos_vec4;\n\n    // Use normalMatrix from ModelUniforms (ensure it's mat3x3<f32> there)\n    vs_out.world_normal = normalize(model_uniforms.normalMatrix * in.normal);\n    vs_out.uv = in.uv; // Pass UVs along\n\n    return vs_out;\n}\n\nfn safe_normalize(v: vec3<f32>) -> vec3<f32> {\n    let len = length(v);\n    if (len < 0.00001) {\n        return vec3<f32>(0.0, 0.0, 1.0);\n    }\n    return v / len;\n}\n\n//--------------------------------------------------------------------\n// Fragment Shader (fs_main)\n//--------------------------------------------------------------------\n@fragment\nfn fs_main(in: VSOut) -> @location(0) vec4<f32> {\n    let N_raw_from_vs = in.world_normal; // This is what VSOut provided\n    let N = safe_normalize(N_raw_from_vs); // Your current N\n    let V = safe_normalize(scene_uniforms.camera_position - in.world_position); // View Vector\n\n    // Base diffuse color for the material\n    var base_diffuse_albedo = material_params.diffuse_color;\n    // If using a texture for diffuse:\n    // if (material_params.diffuse_texture_factor > 0.5) {\n    //     base_diffuse_albedo = textureSample(diffuse_texture, material_sampler, in.uv).rgb * material_params.diffuse_color;\n    // }\n\n    var total_outgoing_radiance = vec3<f32>(0.0);\n    var accumulated_ambient_from_lights = vec3<f32>(0.0);\n\n    for (var i: u32 = 0u; i < scene_uniforms.numLights; i = i + 1u) {\n        let L_info = lights_array[i]; // Current light from the array\n\n        if (L_info.enabled == 0u) { // Skip disabled lights\n            continue;\n        }\n\n        let light_color_final = L_info.color.rgb * L_info.intensity;\n\n        // --- AMBIENT LIGHT TYPE ---\n        if (L_info.lightType == 0u) { // LightType.Ambient\n            accumulated_ambient_from_lights = accumulated_ambient_from_lights + light_color_final;\n        }\n        // --- POINT LIGHT TYPE ---\n        else if (L_info.lightType == 1u) { // LightType.Point\n            let light_world_pos = L_info.matrix[3].xyz; // Position from light's worldMatrix\n            let light_vector = light_world_pos - in.world_position;\n            let distance_to_light = length(light_vector);\n\n            if (distance_to_light < 0.00001) {\n                continue;\n            }\n\n            // Range check\n            if (L_info.range > 0.0 && distance_to_light > L_info.range) {\n                continue;\n            }\n\n            let L = safe_normalize(light_vector); // Direction from surface to light\n\n            // Attenuation\n            let att_const = L_info.attenuation.x;\n            let att_lin = L_info.attenuation.y;\n            let att_quad = L_info.attenuation.z;\n            let attenuation_denominator = att_const + att_lin * distance_to_light + att_quad * distance_to_light * distance_to_light;\n\n            // Prevent division by zero for attenuation, though with att_const=1.0 it shouldn't happen\n            if (attenuation_denominator < 0.00001) {\n                continue;\n            }\n            let attenuation = 1.0 / attenuation_denominator;\n            let effective_light_color = light_color_final * attenuation;\n\n            // Diffuse Reflection (Lambertian)\n            let NdotL = max(dot(N, L), 0.0);\n\n            total_outgoing_radiance = total_outgoing_radiance + (effective_light_color * base_diffuse_albedo * NdotL);\n            \n            // return vec4(total_outgoing_radiance, 1.0);\n\n            // Specular Reflection (Blinn-Phong)\n            let H_vec = L + V;\n            // // return vec4(H_vec, 1.0);\n\n            if (length(H_vec) > 0.00001) {\n                let H = safe_normalize(H_vec); // Halfway vector\n                let NdotH = max(dot(N, H), 0.0);\n                let specular_factor = pow(NdotH, material_params.shininess);\n                total_outgoing_radiance = total_outgoing_radiance + (effective_light_color * material_params.specular_color * specular_factor);\n            }\n        }\n\n        // TODO: Add 'else if' blocks for Directional (type 2) and Spot (type 3) lights\n    }\n\n    // Combine lighting components\n    // Ambient term: Material's ambient reflectivity * sum of all ambient-type lights\n    let final_color = (material_params.ambient_color * accumulated_ambient_from_lights) + total_outgoing_radiance;\n\n    return vec4<f32>(final_color, 1.0); // Output color (alpha usually 1.0 for opaque)\n}\n"},161:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CubeGeometry=void 0;const r=n(80);class i extends r.Geometry{constructor(e){const{vertices:t,indices:n,vertexCount:r,indexCount:i,arrayStride:o}=function(){const e=[[-.5,-.5,.5,0,1,0,0,1],[.5,-.5,.5,1,1,0,0,1],[.5,.5,.5,1,0,0,0,1],[-.5,.5,.5,0,0,0,0,1],[.5,-.5,-.5,1,1,0,0,-1],[-.5,-.5,-.5,0,1,0,0,-1],[-.5,.5,-.5,0,0,0,0,-1],[.5,.5,-.5,1,0,0,0,-1],[.5,-.5,.5,0,1,1,0,0],[.5,-.5,-.5,1,1,1,0,0],[.5,.5,-.5,1,0,1,0,0],[.5,.5,.5,0,0,1,0,0],[-.5,-.5,-.5,1,1,-1,0,0],[-.5,-.5,.5,0,1,-1,0,0],[-.5,.5,.5,0,0,-1,0,0],[-.5,.5,-.5,1,0,-1,0,0],[-.5,.5,.5,0,1,0,1,0],[.5,.5,.5,1,1,0,1,0],[.5,.5,-.5,1,0,0,1,0],[-.5,.5,-.5,0,0,0,1,0],[-.5,-.5,-.5,0,1,0,-1,0],[.5,-.5,-.5,1,1,0,-1,0],[.5,-.5,.5,1,0,0,-1,0],[-.5,-.5,.5,0,0,0,-1,0]],t=[];e.forEach((e=>t.push(...e)));const n=new Float32Array(t),r=e.length,i=[];for(let e=0;e<6;e++){const t=4*e;i.push(t+0,t+1,t+2,t+0,t+2,t+3)}const o=new Uint16Array(i);return{vertices:n,indices:o,vertexCount:r,indexCount:o.length,arrayStride:32,floatsPerVertex:8}}(),a=e.createBuffer(t,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),s=e.createBuffer(n,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST);super(e,a,s,i,r),this._arrayStride=o}get cacheKey(){return"CubeGeometry"}get bufferLayout(){return[{arrayStride:this._arrayStride,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]}}t.CubeGeometry=i},163:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Light=t.LightManager=void 0;var r=n(997);Object.defineProperty(t,"LightManager",{enumerable:!0,get:function(){return r.LightManager}});var i=n(435);Object.defineProperty(t,"Light",{enumerable:!0,get:function(){return i.Light}})},192:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="struct VSOut {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs_main(in: VSIn) -> VSOut {\n  let modelViewProj: mat4x4<f32> = scene_uniforms.projection * scene_uniforms.view * model_uniforms.model;\n\n  let vs_out: VSOut = VSOut(\n    modelViewProj * vec4<f32>(in.position, 1.0),\n    in.uv,\n  );\n  return vs_out;\n}\n\n@fragment\nfn fs_main(vs_out: VSOut) -> @location(0) vec4<f32> {\n  return vec4(vs_out.uv, 0.0, 1.0);\n}\n"},249:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.packUniforms=function(e,t,n=0){let i=0,o=0;const a=[];if(0===e.length)return t||new ArrayBuffer(0);for(const t of e){const e=s(t);o=Math.max(o,e.align),i+=(e.align-i%e.align)%e.align,a.push(Object.assign(Object.assign({},e),{relativeOffset:i,itemData:t})),i+=e.size}const u=i+(o-i%o)%o;let c,l;if(t){if(t.byteLength<n+u)throw new Error(`Target buffer too small. Need ${u} at offset ${n}, but buffer has ${t.byteLength} bytes.`);c=t,l=n}else c=new ArrayBuffer(u),l=0;const f=new DataView(c),d=new Float32Array(c);function h(e,t,n){if(t.isStruct){if("object"!=typeof e||null===e||Array.isArray(e))throw new Error(`Expected an object for struct value "${t.typeName}", but got ${typeof e}`);const r=e;for(const e in t.membersLayout){const i=t.membersLayout[e],o=r[e];if(void 0===o)throw new Error(`Value for struct member "${e}" of struct "${t.typeName}" not provided.`);h(o,i,n+i.relativeOffset)}}else switch(t.typeName){case"u32":if("number"!=typeof e)throw new Error("Type mismatch: Expected number for u32 value, but got "+typeof e);f.setUint32(n,e,!0);break;case"i32":if("number"!=typeof e)throw new Error("Type mismatch: Expected number for i32 value, but got "+typeof e);f.setInt32(n,e,!0);break;case"f32":if("number"!=typeof e)throw new Error("Type mismatch: Expected number for f32 value, but got "+typeof e);f.setFloat32(n,e,!0);break;case"color":if(!(e instanceof r.Color))throw new Error("Type mismatch: Expected Color instance, but got "+typeof e);const i=e.uniformValue();d.set(i,n/4);break;case"vec2":case"vec3":case"vec4":if(!(e instanceof Float32Array))throw new Error(`Type mismatch: Expected Float32Array for ${t.typeName}, but got ${typeof e}`);if(!function(e,t){if(!t)return!0;let n;return n=e instanceof r.Color?4:e.length,n>=t}(e,t.expectedLength))throw new Error(`Not enough data for ${t.typeName}: Expected at least ${t.expectedLength} elements, but got ${e.length}`);const o=e,a=t.expectedLength||o.length,s=o.subarray(0,a);d.set(s,n/4);break;case"mat4":if(!(e instanceof Float32Array))throw new Error("Type mismatch: Expected Float32Array for mat4, but got "+typeof e);if(e.length<16)throw new Error(`Not enough data for mat4: Expected at least 16 elements, but got ${e.length}`);d.set(e.subarray(0,16),n/4);break;case"mat3":if(!(e instanceof Float32Array))throw new Error("Type mismatch: Expected Float32Array for mat3, but got "+typeof e);if(e.length<9)throw new Error(`Not enough data for mat3: Expected at least 9 elements, but got ${e.length}`);const u=e,c=t.paddedStride/4;if(12===u.length&&36===t.size&&16===t.paddedStride)for(let e=0;e<3;++e){const r=e*(12===u.length?4:3),i=n+e*t.paddedStride;d.set(u.subarray(r,r+3),i/4)}else for(let e=0;e<3;++e){const t=3*e,r=n/4+e*c;d.set(u.subarray(t,t+3),r)}break;default:throw new Error(`Unsupported typeName for writing: "${t.typeName}" at offset ${n}`)}}for(const e of a)h(e.itemData.value,e,l+e.relativeOffset);return c},t.uploadUniformBuffer=function(e,t,n="Uniform Buffer",r){const i=null!=r?r:t.createBuffer({label:n,size:e.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,mappedAtCreation:!1});if(r&&r.size<e.byteLength)throw new Error(`Existing buffer is too small. Buffer size: ${r.size}, Data size: ${e.byteLength}`);return t.queue.writeBuffer(i,0,e,0,e.byteLength),i};const r=n(710),i={f32:{typeName:"f32",align:4,size:4,advanceAmount:4},i32:{typeName:"i32",align:4,size:4,advanceAmount:4},u32:{typeName:"u32",align:4,size:4,advanceAmount:4},vec2:{typeName:"vec2",align:8,size:8,advanceAmount:8,expectedLength:2},vec3:{typeName:"vec3",align:16,size:12,advanceAmount:16,expectedLength:3},vec4:{typeName:"vec4",align:16,size:16,advanceAmount:16,expectedLength:4},color:{typeName:"color",align:16,size:16,advanceAmount:16,expectedLength:4},mat3:{typeName:"mat3",align:16,size:36,advanceAmount:48,paddedStride:16,expectedLength:12},mat4:{typeName:"mat4",align:16,size:64,advanceAmount:64,paddedStride:16,expectedLength:16}},o={};function a(e,t){if("number"==typeof e)return Number.isInteger(e)?"u32":"f32";if(e instanceof r.Color)return"color";if(e instanceof Float32Array)switch(e.length){case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";case 9:case 12:return"mat3";case 16:return"mat4";default:throw new Error(`Unsupported Float32Array length for item "${t}" for type inference: ${e.length}. Expected 2, 3, 4, 9, 12, or 16.`)}throw new Error(`Cannot infer base type for item "${t}". Value type: ${typeof e}. If it's a struct, its 'type' (and 'members' if new) must be defined.`)}function s(e){let t=e.type;const n=e.members,r=e.name;if(n){if(!t)throw new Error(`Struct item "${r}" must have a 'type' property defining its name when 'members' are provided.`);if(o[t])return o[t];let i=0,u=0;const c={},l=e.value;if("object"!=typeof e.value||null===e.value||Array.isArray(e.value))throw new Error(`Value for struct "${r}" must be an object when 'members' are defined for layout calculation.`);for(const e of n){const n=e.name,o=l[n];if(void 0===o&&!e.type&&!e.members)throw new Error(`Value for struct member "${n}" of struct "${t}" not provided, and type cannot be inferred.`);let f=e.type;if(f||e.members){if(!f&&e.members)throw new Error(`Inline nested struct member "${n}" within "${t}" must have its own 'type' (name) defined.`)}else{if(void 0===o)throw new Error(`Value for struct member "${n}" needed for type inference.`);f=a(o,`${r}.${n}`)}const d=s({name:n,value:o,type:f,members:e.members});u=Math.max(u,d.align);const h=d.align;i+=(h-i%h)%h,c[n]=Object.assign(Object.assign({},d),{relativeOffset:i}),i+=d.size}const f={align:u,size:i,advanceAmount:i,isStruct:!0,membersLayout:c,typeName:t};return o[t]=f,f}if(t){if(i[t])return i[t];if(o[t])return o[t];throw new Error(`Unknown explicit type "${t}" for item "${r}" and not a defined struct in cache.`)}{const t=a(e.value,r);if(i[t])return i[t];throw new Error(`Could not get layout for inferred type "${t}" for item "${r}".`)}}},286:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TetrahedronGeometry=void 0;const r=n(80);function i(e){const t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return 0===t?[0,0,0]:[e[0]/t,e[1]/t,e[2]/t]}function o(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}class a extends r.Geometry{constructor(e,t={radius:.5}){const{vertices:n,indices:r,vertexCount:a,indexCount:s,arrayStride:u}=function(e=.5){const t=e/Math.sqrt(3),n=[t,t,t],r=[t,-t,-t],a=[-t,t,-t],s=[-t,-t,t],u=[{verts:[n,a,r],uvs:[[.5,1],[0,0],[1,0]]},{verts:[n,r,s],uvs:[[.5,1],[0,0],[1,0]]},{verts:[n,s,a],uvs:[[.5,1],[0,0],[1,0]]},{verts:[r,a,s],uvs:[[0,0],[1,0],[.5,1]]}],c=[],l=[];let f=0;for(const e of u){const[t,n,r]=e.verts,[a,s,u]=e.uvs,_=o(n,t),m=i((h=o(r,t),[(d=_)[1]*h[2]-d[2]*h[1],d[2]*h[0]-d[0]*h[2],d[0]*h[1]-d[1]*h[0]]));c.push(...t,...a,...m),c.push(...n,...s,...m),c.push(...r,...u,...m),l.push(f,f+1,f+2),f+=3}var d,h;const _=new Float32Array(c),m=new Uint16Array(l);return{vertices:_,indices:m,vertexCount:f,indexCount:m.length,arrayStride:32,floatsPerVertex:8}}(t.radius),c=e.createBuffer(n,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),l=e.createBuffer(r,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST);super(e,c,l,s,a),this._arrayStride=u,this._radius=t.radius}get cacheKey(){return`TetrahedronGeometry_r${this._radius}`}get bufferLayout(){return[{arrayStride:this._arrayStride,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]}}t.TetrahedronGeometry=a},325:function(e,t,n){var r,i=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(t,n);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,i)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||(r=function(e){return r=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n);return t},r(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n=r(e),a=0;a<n.length;a++)"default"!==n[a]&&i(t,e,n[a]);return o(t,e),t});Object.defineProperty(t,"__esModule",{value:!0}),t.lights=t.fluid=t.compute=t.material=t.geometry=t.camera=t.Transform=t.Scene=t.ImageTexture=t.DefaultTexture=t.Color=t.Renderer=void 0;var s=n(366);Object.defineProperty(t,"Renderer",{enumerable:!0,get:function(){return s.Renderer}});var u=n(710);Object.defineProperty(t,"Color",{enumerable:!0,get:function(){return u.Color}});var c=n(330);Object.defineProperty(t,"DefaultTexture",{enumerable:!0,get:function(){return c.DefaultTexture}}),Object.defineProperty(t,"ImageTexture",{enumerable:!0,get:function(){return c.ImageTexture}});var l=n(41);Object.defineProperty(t,"Scene",{enumerable:!0,get:function(){return l.Scene}});var f=n(541);Object.defineProperty(t,"Transform",{enumerable:!0,get:function(){return f.Transform}}),t.camera=a(n(149)),t.geometry=a(n(722)),t.material=a(n(760)),t.compute=a(n(898)),t.fluid=a(n(482)),t.lights=a(n(163))},330:function(e,t){var n=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.ImageTexture=t.DefaultTexture=t.MappedTexture=t.Texture=void 0;class r{constructor(){}}t.Texture=r,t.MappedTexture=class extends r{constructor(e){super(),this._descriptor=e}get descriptor(){return this._descriptor}get view(){return this._view||(this._view=this._texture.createView()),this._view}upload(e){this._texture=e.createTexture(this.descriptor)}dispose(){this._texture.destroy()}get width(){return this._texture.width}get height(){return this._texture.height}get label(){return this._texture.label}get format(){return this._texture.format}get dimension(){return this._texture.dimension}};class i extends r{constructor(){super(),this._texture=null,this._textureView=null,this._pixelData=new Uint8Array([255,255,255,255])}get width(){return 1}get height(){return 1}get descriptor(){return{size:{width:1,height:1,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,dimension:"2d",mipLevelCount:1,sampleCount:1}}get view(){var e;if(!this._texture)throw new Error("Texture not created");return null!==(e=this._textureView)&&void 0!==e||(this._textureView=this._texture.createView()),this._textureView}get label(){return"Default Texture"}get format(){return this._texture.format}get dimension(){return this._texture.dimension}upload(e){this._texture||(this._texture=e.createTexture(this.descriptor),e.queue.writeTexture({texture:this._texture,mipLevel:0,origin:{x:0,y:0,z:0}},this._pixelData,{offset:0,bytesPerRow:4,rowsPerImage:1},{width:1,height:1,depthOrArrayLayers:1}))}dispose(){var e;null===(e=this._texture)||void 0===e||e.destroy(),this._texture=null,this._textureView=null}}t.DefaultTexture=i,i.instance=new i,t.ImageTexture=class extends r{constructor(e){super(),this._width=0,this._height=0,this._texture=null,this._textureView=null,this._imagedata=null,this.src=e}load(){return n(this,void 0,void 0,(function*(){const e=yield fetch(this.src);if(!e.ok)throw new Error(`Failed to load image: ${this.src}`);const t=yield e.blob(),n=yield createImageBitmap(t);this._imagedata=n,this._width=n.width,this._height=n.height}))}get width(){return this._width}get height(){return this._height}get descriptor(){return{size:{width:this._width,height:this._height,depthOrArrayLayers:1},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,dimension:"2d",mipLevelCount:1,sampleCount:1}}get view(){var e;if(!this._texture)throw new Error("Texture not created");return null!==(e=this._textureView)&&void 0!==e||(this._textureView=this._texture.createView()),this._textureView}get label(){return`ImageTexture ${this.src}`}get format(){return this._texture.format}get dimension(){return this._texture.dimension}upload(e){if(!this._texture){if(!this._imagedata)throw new Error("Image not loaded");this._texture=e.createTexture(this.descriptor),e.queue.copyExternalImageToTexture({source:this._imagedata,origin:{x:0,y:0},flipY:!0},{texture:this._texture,origin:{x:0,y:0}},{width:this._width,height:this._height,depthOrArrayLayers:1})}}dispose(){var e,t;null===(e=this._imagedata)||void 0===e||e.close(),null===(t=this._texture)||void 0===t||t.destroy(),this._texture=null,this._textureView=null,this._imagedata=null,this._width=0,this._height=0}}},331:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.UVMaterial=void 0;const i=n(35),o=r(n(414)),a=r(n(192));class s extends i.Material{constructor(e){super(),s.precompile(e)}get cacheKey(){return"UVMaterial"}get shaderCode(){return s.shaderModule}static precompile(e){s.shaderModule||(s.shaderModule=e.createShaderModule({label:"basic-material-shader",code:`\n${o.default}\n${a.default}\n`}))}}t.UVMaterial=s,s.shaderModule=null},342:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.BlinnPhongMaterial=void 0;const i=n(35),o=n(343),a=n(717),s=r(n(414)),u=r(n(157));class c extends i.Material{constructor(e,t){const n=t.ambientColor||a.vec3.fromValues(.1,.1,.1),r=t.diffuseColor||a.vec3.fromValues(.7,.7,.7),i=t.specularColor||a.vec3.fromValues(1,1,1),s=t.shininess||32,u=[{name:"ambient_color",value:n,type:"vec3"},{name:"diffuse_color",value:r,type:"vec3"},{name:"specular_color",value:i,type:"vec3"},{name:"shininess",value:s,type:"f32"}];super(new o.UniformManager(e,{label:"BlinnPhongMaterial_Params",uniforms:u})),this._device=e,this.ambientColor=n,this.diffuseColor=r,this.specularColor=i,this.shininess=s}get cacheKey(){return`blinn-phong-${this.ambientColor.join(",")}-${this.diffuseColor.join(",")}-${this.specularColor.join(",")}-${this.shininess}`}get shaderCode(){return c.precompile(this._device),c.shaderModule}update(){this._uniformManager.updateUniform({name:"ambient_color",value:this.ambientColor}),this._uniformManager.updateUniform({name:"diffuse_color",value:this.diffuseColor}),this._uniformManager.updateUniform({name:"specular_color",value:this.specularColor}),this._uniformManager.updateUniform({name:"shininess",value:this.shininess}),super.update()}static precompile(e){c.shaderModule||(c.shaderModule=e.createShaderModule({label:"basic-material-shader",code:`\n${s.default}\n${u.default}\n`}))}}t.BlinnPhongMaterial=c,c.shaderModule=null},343:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UniformManager=void 0;const r=n(249);t.UniformManager=class{constructor(e,t){this._uniformsDirty=!0,this._texturesDirty=!0,this._buffersDirty=!0,this._compute=!1,this.uniformVisibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._device=e;const{uniforms:n,textures:r,buffers:i,samplers:o,label:a,uniformVisibility:s,compute:u}=t;this._uniforms=n,this._textures=r,this._buffers=i,this._samplers=o,this._label=a,this._uniformsDirty=!0,this._texturesDirty=!0,this._compute=Boolean(u),s&&(this.uniformVisibility=s),(this._samplers||[]).length<1&&(this._textures||[]).length>0&&(this._samplers=[{sampler:this._device.createSampler({magFilter:"linear",minFilter:"linear"}),type:"filtering"}])}get cacheKey(){if(this._cacheKey)return this._cacheKey;const e=[this._label];for(const t of this._uniforms||[])e.push(t.name);for(const t of this._textures||[])e.push(t.texture.label);for(const t of this._buffers||[])e.push(t.buffer.label);for(const t of this._samplers||[])e.push(t.sampler.label);return this._cacheKey=e.join(":"),this._cacheKey}updateUniform(e){var t;(null===(t=this._uniforms)||void 0===t?void 0:t.find((t=>t.name===e.name))).value=e.value,this.setUniformsDirty()}updateUniforms(e){this._uniforms=e,this.setUniformsDirty()}updateTextures(e){this._textures=e,this.setTexturesDirty()}updateBuffers(e){this._buffers=e,this.setBuffersDirty()}update(){this._uniformsDirty&&(this._uniformArr=(0,r.packUniforms)(this._uniforms||[],this._uniformArr),this._uniformBuffer=(0,r.uploadUniformBuffer)(this._uniformArr,this._device,this._label,this._uniformBuffer),this._uniformsDirty=!1),this._texturesDirty&&((this._textures||[]).forEach((e=>e.texture.upload(this._device))),this._texturesDirty=!1),this._buffersDirty&&(this._bindGroup=void 0,this._bindGroupLayout=void 0)}setTexturesDirty(){this._texturesDirty=!0}setUniformsDirty(){this._uniformsDirty=!0}setBuffersDirty(){this._buffersDirty=!0}setDirty(){this.setTexturesDirty(),this.setUniformsDirty()}get buffers(){return this._buffers}get bindGroupLayoutDescriptor(){const e=[];let t=0;const{_uniforms:n,_textures:r,_samplers:i,_buffers:o}=this;if((null==n?void 0:n.length)>0&&(e.push({binding:0,visibility:this.uniformVisibility,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:0}}),t++),(null==i?void 0:i.length)>0){const n=this._compute?GPUShaderStage.COMPUTE:GPUShaderStage.FRAGMENT;for(let r=0;r<i.length;r++)e.push({binding:t,visibility:i[r].visibility||n,sampler:{type:i[r].type}}),t++}if((null==r?void 0:r.length)>0){const n=this._compute?GPUShaderStage.COMPUTE:GPUShaderStage.FRAGMENT;for(let i=0;i<(null==r?void 0:r.length);i++){const o=r[i],a=o.dimension||o.texture.dimension,s=o.accessType||"sample";if("sample"===s)e.push({binding:t,visibility:o.visibility||n,texture:{sampleType:"float",viewDimension:a,multisampled:!1}});else{const r=o.format||o.texture.format;e.push({binding:t,visibility:o.visibility||n,storageTexture:{access:s,format:r,viewDimension:a}})}t++}}if((null==o?void 0:o.length)>0)for(let n=0;n<(null==o?void 0:o.length);n++)e.push({binding:t,visibility:o[n].visibility,buffer:{type:o[n].type}}),t++;return{label:`${this._label} BindGroup Layout`,entries:e}}get bindGroupLayout(){return this._bindGroupLayout||(this._bindGroupLayout=this._device.createBindGroupLayout(this.bindGroupLayoutDescriptor)),this._bindGroupLayout}get bindGroupDescriptor(){let e=0;const{_uniforms:t,_textures:n,_samplers:r,_buffers:i}=this,o=[];if((null==t?void 0:t.length)>0&&(o.push({binding:e,resource:{buffer:this._uniformBuffer}}),e++),(null==r?void 0:r.length)>0)for(let t=0;t<r.length;t++)o.push({binding:e,resource:r[t].sampler}),e++;if((null==n?void 0:n.length)>0)for(let t=0;t<(null==n?void 0:n.length);t++)o.push({binding:t+e,resource:n[t].texture.view});if((null==i?void 0:i.length)>0)for(let t=0;t<(null==i?void 0:i.length);t++)o.push({binding:e,resource:{buffer:i[t].buffer}}),e++;return{label:`${this._label} BindGroup`,layout:this.bindGroupLayout,entries:o}}get bindGroup(){return this._bindGroup||(this._bindGroup=this._device.createBindGroup(this.bindGroupDescriptor)),this._bindGroup}}},366:function(e,t,n){var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((r=r.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.Renderer=void 0;const i=n(717),o=n(779),a=n(599),s=n(108),u=n(41),c=n(898),l=n(330);t.Renderer=class{constructor(e={}){var t;this.adapter=null,this.depthFormat="depth24plus-stencil8",this.format="bgra8unorm",this.canvasSize=i.vec2.create(1,1),this.sizeDirty=!0,this._pipelineCache=new Map,this._computePipelineCache=new Map,null!==(t=this.canvas)&&void 0!==t||(this.canvas=e.canvas),console.log("Renderer initialized")}init(){return r(this,void 0,void 0,(function*(){if(!navigator.gpu)throw new Error("WebGPU is not supported in this browser");if(this.adapter=yield navigator.gpu.requestAdapter(),!this.adapter)throw new Error("No GPU adapter found");this.device=yield this.adapter.requestDevice(),console.log("GPU device initialized"),this.canvas&&this.initCanvas(this.canvas)}))}initCanvas(e){var t;if(this.canvas=e,this.context=null===(t=this.canvas)||void 0===t?void 0:t.getContext("webgpu"),!this.context)throw new Error("Failed to get WebGPU context");this.format=navigator.gpu.getPreferredCanvasFormat(),this.context.configure({device:this.device,format:this.format,alphaMode:"premultiplied"});const n=()=>{var e;const t=this.canvas.offsetWidth,n=this.canvas.offsetHeight;t===this.canvasSize[0]&&n===this.canvasSize[1]||(this.canvas.width=t,this.canvas.height=n,this.canvasSize.set([t,n]),this.sizeDirty=!0,null===(e=this.depthTexture)||void 0===e||e.destroy(),this.depthTexture=this.device.createTexture({label:"Depth texture",size:{width:t,height:n},format:this.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.depthTextureView=this.depthTexture.createView({label:"Depth texture view "}))};this.resizeObserver=new ResizeObserver(n),this.resizeObserver.observe(this.canvas),n(),console.log("Canvas initialized")}createShaderModule(e){return this.device.createShaderModule(e)}createBuffer(e,t){const n=this.device.createBuffer({size:e.byteLength+3&-4,usage:t,mappedAtCreation:!0});return e instanceof Float32Array?new Float32Array(n.getMappedRange()).set(e):e instanceof Uint32Array?new Uint32Array(n.getMappedRange()).set(e):e instanceof Uint16Array?new Uint16Array(n.getMappedRange()).set(e):e instanceof Uint8Array&&new Uint8Array(n.getMappedRange()).set(e),n.unmap(),n}createSizedBuffer(e,t){return this.device.createBuffer({size:e,usage:t})}pipelineFor(e,t){const n=t.cacheKey;if(this._pipelineCache.has(n))return this._pipelineCache.get(n);const r=t.material.shaderCode,i=t.bufferLayout,o=this.device.createPipelineLayout({label:"Pipeline Layout",bindGroupLayouts:[e.bindGroupLayout,t.bindGroupLayout,t.material.bindGroupLayout]}),a=this.device.createRenderPipeline({layout:o,vertex:{module:r,buffers:i},fragment:{module:r,targets:[{format:this.format}]},primitive:{topology:"triangle-list",stripIndexFormat:void 0,frontFace:"ccw",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}});return this._pipelineCache.set(n,a),a}render(e,t){const[n,r]=this.canvasSize,i={label:"Render pass",colorAttachments:[{view:this.context.getCurrentTexture().createView({label:"Canvas output texture view"}),clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilLoadOp:"clear",stencilStoreOp:"store"}},o=this.device.createCommandEncoder(),a=o.beginRenderPass(i);a.setViewport(0,0,n,r,0,1),a.setScissorRect(0,0,n,r),this.sizeDirty&&(t.viewportResized(this.canvasSize),this.sizeDirty=!1),e.update(t,this.canvasSize);const u=e.bindGroup;a.setBindGroup(0,u),e.traverse((t=>{if(t instanceof s.Mesh){const n=t;n.update();const r=this.pipelineFor(e,n);a.setPipeline(r),a.setBindGroup(1,n.bindGroup),a.setBindGroup(2,n.material.bindGroup),a.setVertexBuffer(0,n.geometry.vertexBuffer),a.setIndexBuffer(n.geometry.indexBuffer,"uint16"),a.drawIndexed(n.geometry.indexCount,n.instanceCount)}})),a.end(),this.device.queue.submit([o.finish()])}computePipelineFor(e){if(!this._computePipelineCache[e.cacheKey]){const t=e.bindGroupLayout,n=this.device.createPipelineLayout({label:`${e.label} Pipeline Layout`,bindGroupLayouts:[t]}),r=this.device.createComputePipeline({layout:n,compute:{entryPoint:e.entryPoint,module:e.shaderModule}});this._computePipelineCache[e.cacheKey]=r}return this._computePipelineCache[e.cacheKey]}compute(e){const t=this.device.createCommandEncoder(),n=t.beginComputePass();for(const t of e){const e=this.computePipelineFor(t),r=t.dispatchCount,i=t.bindGroup;n.setPipeline(e),n.setBindGroup(0,i),n.dispatchWorkgroups(r[0],r[1],r[2])}n.end(),this.device.queue.submit([t.finish()])}createMaterial(e,t){return new e(this.device,t)}createGeometry(e,t){return new e(this,t)}createMesh(e,t,n,r){return new s.Mesh(this.device,t,e,n,r)}createScene(){return new u.Scene(this)}createPerspectiveCamera(e){return new a.PerspectiveCamera(e)}createOrthographicCamera(e){return new o.OrthographicCamera(e)}loadImageTexture(e){return r(this,void 0,void 0,(function*(){const t=new l.ImageTexture(e);return yield t.load(),t.upload(this.device),t}))}createTexture(e){const t=new l.MappedTexture(e);return t.upload(this.device),t}createSampler(e){return this.device.createSampler(e)}createComputeTask(e){return new c.ComputeTask(this.device,e)}}},386:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="//--------------------------------------------------------------------------------------\n// Structures\n//--------------------------------------------------------------------------------------\nstruct SimParams {\n    dt: f32,\n    dx: f32,\n    inv_dx: f32,\n    grid_size: u32,\n    dimensions: u32,\n    num_particles: u32,\n\n    particle_initial_volume: f32,\n    particle_mass_param: f32,\n    gravity: f32,\n\n    mu_0: f32,\n    lambda_0: f32,\n    fluid_stiffness_Ef: f32,\n\n    snow_plasticity_h_factor: f32,\n    snow_yield_min: f32,\n    snow_yield_max: f32,\n\n    boundary_extent: u32,\n};\n\nstruct Particle {\n    position: vec3<f32>,\n    velocity: vec3<f32>,\n    affine_matrix_C: mat3x3<f32>,\n    deformation_gradient_F: mat3x3<f32>,\n    mass: f32,\n    Jp: f32,\n    Jf: f32,\n    material_idx: u32,\n};\n\nconst FIXED_POINT_MULTIPLIER: f32 = 10000.0; // Define your multiplier\nconst FIXED_POINT_MULTIPLIER_INV: f32 = 1.0 / FIXED_POINT_MULTIPLIER;\nconst DIMENSIONS = 3u;\n\nfn encodeFixedPoint(val: f32) -> i32 {\n    return i32(val * FIXED_POINT_MULTIPLIER);\n}\n\nfn decodeFixedPoint(fixed_val: i32) -> f32 {\n    return f32(fixed_val) * FIXED_POINT_MULTIPLIER_INV;\n}\n\nfn grid_idx_flat_clamp(cell_coords_abs: vec3<i32>, n_grid: u32) -> u32 {\n    // Ensure positive before casting for safety if cell_coords_abs can be negative\n    // However, for reading, we expect them to be valid after boundary checks if any.\n    // For G2P, particle can be near boundary, so stencil nodes can be out of bounds.\n    let x = u32(clamp(cell_coords_abs.x, 0, i32(n_grid - 1u)));\n    let y = u32(clamp(cell_coords_abs.y, 0, i32(n_grid - 1u)));\n    let z = u32(clamp(cell_coords_abs.z, 0, i32(n_grid - 1u)));\n    return x * n_grid * n_grid + y * n_grid + z;\n}\n\nfn grid_idx_flat(cell_coords_abs: vec3<i32>, n_grid: u32) -> u32 {\n    return u32(cell_coords_abs.x) * n_grid * n_grid +\n           u32(cell_coords_abs.y) * n_grid +\n           u32(cell_coords_abs.z);\n}\n\n// Helper to convert 1D flat grid index to 3D integer grid coordinates\nfn flat_idx_to_3d_coords(flat_idx: u32, n_grid: u32) -> vec3<i32> {\n    let z = i32(flat_idx / (n_grid * n_grid));\n    let remainder = flat_idx % (n_grid * n_grid);\n    let y = i32(remainder / n_grid);\n    let x = i32(remainder % n_grid);\n    return vec3<i32>(x, y, z);\n}\n\n// Helper for APIC B-Spline\n// u is distance from particle to grid node center, in units of cell sizes\nfn quadratic_bspline_N(u : f32) -> f32 {\n    let abs_u = abs(u);\n    var N_u = 0.0;\n    if (abs_u < 0.5) {\n        N_u = 0.75 - abs_u * abs_u;\n    } else if (abs_u < 1.5) {\n        N_u = 0.5 * (1.5 - abs_u) * (1.5 - abs_u);\n    }\n    return N_u;\n}\n"},414:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="const BG_SCENE: u32 = 0;\nconst BG_MODEL: u32 = 1;\nconst BG_UNIFORMS: u32 = 2;\n\nstruct SceneUniforms {\n  projection: mat4x4<f32>,\n  view: mat4x4<f32>,\n  camera_position: vec3<f32>,\n  resolution: vec2<f32>,\n  time: f32,\n  numLights: u32,\n}\n\nstruct ModelUniforms {\n  model: mat4x4<f32>,\n  normalMatrix: mat3x3<f32>,\n}\n\nstruct VSIn {\n  @location(0) position: vec3f,\n  @location(1) uv: vec2f,\n  @location(2) normal: vec3f,\n}\n\n@group(BG_SCENE) @binding(0) var<uniform> scene_uniforms: SceneUniforms;\n@group(BG_MODEL) @binding(0) var<uniform> model_uniforms: ModelUniforms;\n\nfn projectionView() -> mat4x4<f32> {\n  return scene_uniforms.projection * scene_uniforms.view;\n}\n\nfn viewModel() -> mat4x4<f32> {\n  return scene_uniforms.view * model_uniforms.model;\n}\n\nfn projectionViewModel() -> mat4x4<f32> {\n    return scene_uniforms.projection * scene_uniforms.view * model_uniforms.model;\n}\n\n// Resize the UVs of the texture so it centers and covers the screen\nfn arFill(texSize: vec2f, screenSize: vec2f, uv: vec2f) -> vec2f {\n  let texAr = texSize.x / texSize.y;\n  let screenAr = screenSize.x / screenSize.y;\n  let dAr = texAr / screenAr;\n\n  // Decide whether the image will be taller or wider than the screen\n  let ar = mix(vec2(1.0, dAr), vec2(1.0 / dAr, 1.0), step(1.0, dAr));\n\n  // Center along the axis that's larger than the screen\n  let offset = mix(vec2(0.0, 1.0 / screenAr - 1.0 / texAr), vec2(screenAr - texAr, 0.0), step(1.0, dAr));\n\n  // uv will be either wider or taller than the canvas at the correct aspect ratio, centered\n  let ret = uv * ar - offset * 0.5;\n\n  return ret;\n}\n"},435:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Light=t.SHADER_LIGHT_MEMBERS_LAYOUT=t.SHADER_LIGHT_STRUCT_TYPE_NAME=t.LightType=void 0;const r=n(717),i=n(541),o=n(710);var a;!function(e){e[e.Ambient=0]="Ambient",e[e.Point=1]="Point"}(a||(t.LightType=a={})),t.SHADER_LIGHT_STRUCT_TYPE_NAME="ShaderLight",t.SHADER_LIGHT_MEMBERS_LAYOUT=[{name:"matrix",type:"mat4"},{name:"attenuation",type:"vec3"},{name:"color",type:"color"},{name:"intensity",type:"f32"},{name:"range",type:"f32"},{name:"lightType",type:"u32"},{name:"enabled",type:"u32"},{name:"radius",type:"f32"}];class s extends i.Transform{constructor(e=a.Point,t=new o.Color(1,1,1),n=1,i=!0,s=10,u=r.vec3.create(1,.09,.032),c=5){super(),this.lightType=e,this.color=t,this.intensity=n,this.enabled=i?1:0,this.range=s,this.attenuation=u,this.radius=c}encode(){const e={matrix:this.worldMatrix,enabled:this.enabled?1:0,lightType:this.lightType},n=t.SHADER_LIGHT_MEMBERS_LAYOUT.reduce(((t,{name:n})=>(t[n]=e[n]||this[n],t)),{});return{name:t.SHADER_LIGHT_STRUCT_TYPE_NAME,type:t.SHADER_LIGHT_STRUCT_TYPE_NAME,members:t.SHADER_LIGHT_MEMBERS_LAYOUT,value:n}}}t.Light=s},482:function(e,t,n){var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,s)}u((r=r.apply(e,t||[])).next())}))},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.FluidSimulation=t.FluidSimulationOptions=void 0;const o=n(717),a=i(n(386)),s=i(n(819)),u=i(n(950)),c=i(n(861)),l=n(249);class f{constructor(e,t){this.particles=e,this.gridSize=t,this.dimensions=3,this.dt=1e-4,this.dx=1/this.gridSize,this.invDx=this.gridSize,this.particleInitialVolume=Math.pow(1/this.gridSize*.5,this.dimensions),this.particleMass=1,this.gravity=9.8,this.mu0=5e3/2.4,this.lambda0=1e3/.72,this.fluidStiffnessEf=400,this.snowPlasticityHFactor=10,this.snowYieldMin=.975,this.snowYieldMax=1.0044,this.boundaryExtent=3}asUniformItems(){return[{name:"dt",value:this.dt,type:"f32"},{name:"dx",value:this.dx,type:"f32"},{name:"inv_dx",value:this.invDx,type:"f32"},{name:"grid_size",value:this.gridSize,type:"u32"},{name:"dimensions",value:this.dimensions,type:"u32"},{name:"num_particles",value:this.particles,type:"u32"},{name:"particle_initial_volume",value:this.particleInitialVolume,type:"f32"},{name:"particle_mass_param",value:this.particleMass,type:"f32"},{name:"gravity",value:this.gravity,type:"f32"},{name:"mu_0",value:this.mu0,type:"f32"},{name:"lambda_0",value:this.lambda0,type:"f32"},{name:"fluid_stiffness_Ef",value:this.fluidStiffnessEf,type:"f32"},{name:"snow_plasticity_h_factor",value:this.snowPlasticityHFactor,type:"f32"},{name:"snow_yield_min",value:this.snowYieldMin,type:"f32"},{name:"snow_yield_max",value:this.snowYieldMax,type:"f32"},{name:"boundary_extent",value:this.boundaryExtent,type:"u32"}]}}t.FluidSimulationOptions=f,t.FluidSimulation=class{constructor(e,t=new f(64e3,128)){this.pingpong=0,this.renderer=e,this.options=t;const n=Math.pow(t.gridSize,t.dimensions);this.gridMassBuffer=e.createBuffer(new Uint32Array(n),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.gridMomentumBuffer=e.createBuffer(new Uint32Array(n*this.options.dimensions),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.gridVelocityBuffer=e.createBuffer(new Float32Array(n*this.options.dimensions),GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.uniformArr=(0,l.packUniforms)(this.options.asUniformItems(),this.uniformArr),this.uniformBuffer=(0,l.uploadUniformBuffer)(this.uniformArr,this.renderer.device),this.particleBufferA=this.initializeParticleBuffer(),this.particleBufferB=this.initializeParticleBuffer();const r=e.createShaderModule({code:a.default+s.default,label:"Stage 1"}),i=e.createShaderModule({code:a.default+u.default,label:"Stage 2"}),d=e.createShaderModule({code:a.default+c.default,label:"Stage 3"}),h=Math.ceil(this.options.particles/64),_=Math.ceil(this.options.gridSize/4);this.stage1=[this.initializeComputePass("Stage 1 A",o.vec3.create(h,1,1),r,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.particleBufferA,"read-only-storage"),this.getBufferItem(this.particleBufferB,"storage")]),this.initializeComputePass("Stage 1 B",o.vec3.create(h,1,1),r,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.particleBufferB,"read-only-storage"),this.getBufferItem(this.particleBufferA,"storage")])],this.stage2=this.initializeComputePass("Stage 2",o.vec3.create(_,_,_),i,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridMassBuffer,"storage"),this.getBufferItem(this.gridMomentumBuffer,"storage"),this.getBufferItem(this.gridVelocityBuffer,"storage")]),this.stage3=[this.initializeComputePass("Stage 3 A",o.vec3.create(h,1,1),d,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridVelocityBuffer,"read-only-storage"),this.getBufferItem(this.particleBufferA,"read-only-storage"),this.getBufferItem(this.particleBufferB,"storage")]),this.initializeComputePass("Stage 3 B",o.vec3.create(h,1,1),d,[this.getBufferItem(this.uniformBuffer,"uniform"),this.getBufferItem(this.gridVelocityBuffer,"read-only-storage"),this.getBufferItem(this.particleBufferB,"read-only-storage"),this.getBufferItem(this.particleBufferA,"storage")])];const m=144*this.options.particles;this.particleStagingBuffer=this.renderer.device.createBuffer({size:m,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"ParticleStagingBuffer"}),this.particleDataForReadback=new ArrayBuffer(m),this.gridVelocityStagingBuffer=this.renderer.device.createBuffer({size:n*t.dimensions*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:"VelocityStagingBuffer"})}getBufferItem(e,t){return{buffer:e,type:t,visibility:GPUShaderStage.COMPUTE}}initializeComputePass(e,t,n,r){const i=this.renderer.createComputeTask({label:e,shader:n,entryPoint:"main",dispatchCount:t,buffers:r});return{task:i,bindGroup:i.bindGroup,pipeline:this.renderer.computePipelineFor(i)}}initializeParticleBuffer(){const e=performance.now(),t={position:o.vec3.create(),velocity:o.vec3.create(),affineMatrixC:o.mat3.create(),deformationGradientF:o.mat3.identity(),mass:this.options.particleMass,Jf:1,Jp:1,materialIndex:0},n=Object.keys(t).map((e=>({name:e}))),r=(0,l.packUniforms)([{name:"Particle",type:"Particle",members:n,value:t}]),i=new Uint8Array(r),a=r.byteLength,s=a*this.options.particles,u=new Uint8Array(s),c=o.vec3.create(),f=new Uint8Array(c.buffer),d=Math.ceil(Math.cbrt(this.options.particles));for(let e=0;e<this.options.particles;e++){const t=Math.floor(e/(d*d))-.5*d,n=Math.floor(e%(d*d)/d)-.5*d,r=e%d-.5*d;c.set([t,n,r]),o.vec3.mulScalar(c,2,c),i.set(f,0),u.set(i,e*a)}const h=this.renderer.createBuffer(u,GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC|GPUBufferUsage.STORAGE);return console.log(`Created position buffer in ${performance.now()-e}ms`),h}tick(){const e=this.renderer.device.createCommandEncoder();e.clearBuffer(this.gridMassBuffer,0),e.clearBuffer(this.gridMomentumBuffer,0);const t=e.beginComputePass(),n=this.stage1[this.pingpong],r=this.stage2,i=this.stage3[this.pingpong],o=n.task.dispatchCount;t.setPipeline(n.pipeline),t.setBindGroup(0,n.bindGroup),t.dispatchWorkgroups(o[0],o[1],o[2]);const a=r.task.dispatchCount;t.setPipeline(r.pipeline),t.setBindGroup(0,r.bindGroup),t.dispatchWorkgroups(a[0],a[1],a[2]);const s=i.task.dispatchCount;t.setPipeline(i.pipeline),t.setBindGroup(0,i.bindGroup),t.dispatchWorkgroups(s[0],s[1],s[2]),t.end();const u=0===this.pingpong?this.particleBufferA:this.particleBufferB,c=144*this.options.particles;e.copyBufferToBuffer(u,0,this.particleStagingBuffer,0,c),e.copyBufferToBuffer(this.gridVelocityBuffer,0,this.gridVelocityStagingBuffer,0,this.gridVelocityBuffer.size),this.renderer.device.queue.submit([e.finish()]),this.pingpong=1-this.pingpong}inspectParticles(){return r(this,arguments,void 0,(function*(e=5){try{yield this.particleStagingBuffer.mapAsync(GPUMapMode.READ,0,this.particleStagingBuffer.size);const t=this.particleStagingBuffer.getMappedRange().slice(0);this.particleStagingBuffer.unmap();const n=[],r=144,i=new DataView(t);for(let t=0;t<Math.min(e,this.options.particles);t++){const e=t*r,a={};a.position=o.vec3.fromValues(i.getFloat32(e+0,!0),i.getFloat32(e+4,!0),i.getFloat32(e+8,!0)),a.velocity=o.vec3.fromValues(i.getFloat32(e+16,!0),i.getFloat32(e+20,!0),i.getFloat32(e+24,!0));const s=i.getFloat32(e+32,!0),u=i.getFloat32(e+36,!0),c=i.getFloat32(e+40,!0),l=i.getFloat32(e+32+16,!0),f=i.getFloat32(e+36+16,!0),d=i.getFloat32(e+40+16,!0),h=i.getFloat32(e+32+32,!0),_=i.getFloat32(e+36+32,!0),m=i.getFloat32(e+40+32,!0);a.affineMatrixC=o.mat3.create(s,u,c,l,f,d,h,_,m),i.getFloat32(e+80,!0),a.deformationGradientF=o.mat3.identity(),a.mass=i.getFloat32(e+128,!0),a.Jp=i.getFloat32(e+132,!0),a.Jf=i.getFloat32(e+136,!0),a.materialIndex=i.getUint32(e+140,!0),n.push(a)}console.log("Readback Particles:",JSON.stringify(n))}catch(e){console.error("Failed to map staging buffer or read particles:",e)}}))}inspectGridVelocities(){return r(this,arguments,void 0,(function*(e=100){try{yield this.gridVelocityStagingBuffer.mapAsync(GPUMapMode.READ,0,this.gridVelocityStagingBuffer.size);const t=this.gridVelocityStagingBuffer.getMappedRange().slice(0);this.gridVelocityStagingBuffer.unmap();const n=[],r=new DataView(t),i=Math.pow(this.options.gridSize,this.options.dimensions);for(let t=0;t<Math.min(e,i);t++){const e=3*t*4,i=r.getFloat32(e+0,!0),o=r.getFloat32(e+4,!0),a=r.getFloat32(e+8,!0);0===i&&0===o&&0===a||n.push({x:i,y:o,z:a})}n.length>0?console.log("Readback Grid Velocities (non-zero):",JSON.stringify(n,null,2)):console.log("Readback Grid Velocities: All logged cells are zero.")}catch(e){console.error("Failed to map or read grid velocity staging buffer:",e)}}))}}},534:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Camera=void 0;const r=n(717),i=n(541);class o extends i.Transform{constructor(){super(),this._isProjectionDirty=!0,this._isViewDirty=!0,this._projectionMatrix=r.mat4.identity(),this._viewMatrix=r.mat4.identity(),this._isProjectionDirty=!0,this._isViewDirty=!0}get projectionMatrix(){return this._isProjectionDirty&&this.updateProjectionMatrix(),this._projectionMatrix}get viewMatrix(){return this._isViewDirty&&this.updateViewMatrix(),this._viewMatrix}updateMatrices(){this._isProjectionDirty&&this.updateProjectionMatrix(),this._isViewDirty&&this.updateViewMatrix()}}t.Camera=o},541:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Transform=void 0;const r=n(717);t.Transform=class{constructor(){this._children=[],this._position=r.vec3.create(0,0,0),this._rotation=r.quat.identity(),this._scale=r.vec3.create(1,1,1),this._localMatrix=r.mat4.identity(),this._worldMatrix=r.mat4.identity(),this._localDirty=!0,this._worldDirty=!0}get position(){return this._position}get quaternion(){return this._rotation}get scale(){return this._scale}set position(e){r.vec3.equals(this._position,e)||(this._position=r.vec3.copy(e,this._position),this.makeDirty())}set quaternion(e){r.quat.equals(this._rotation,e)||(this._rotation=r.quat.copy(e,this._rotation),this.makeDirty())}set scale(e){r.vec3.equals(this._scale,e)||(this._scale=r.vec3.copy(e,this._scale),this.makeDirty())}setPosition(e,t,n){this.position=r.vec3.create(e,t,n)}setRotation(e,t,n,i="xyz"){this._rotation=r.quat.fromEuler(e,t,n,i),this.makeDirty()}setScale(e,t,n){this.scale=r.vec3.create(e,t,n)}get localMatrix(){return this._localDirty&&this.updateLocalMatrix(),this._localMatrix}get worldMatrix(){return(this._localDirty||this._worldDirty)&&this.updateWorldMatrix(),this._worldMatrix}updateLocalMatrix(){!function(e,t,n,i){i||(i=r.mat4.create());const[o,a,s,u]=t,c=o+o,l=a+a,f=s+s,d=o*c,h=a*l,_=s*f,m=o*l,p=o*f,g=a*f,v=u*c,y=u*l,b=u*f,[x,M,w]=n;i[0]=(1-(h+_))*x,i[1]=(m+b)*x,i[2]=(p-y)*x,i[3]=0,i[4]=(m-b)*M,i[5]=(1-(d+_))*M,i[6]=(g+v)*M,i[7]=0,i[8]=(p+y)*w,i[9]=(g-v)*w,i[10]=(1-(d+h))*w,i[11]=0,i[12]=e[0],i[13]=e[1],i[14]=e[2],i[15]=1}(this._position,this._rotation,this._scale,this._localMatrix),this._localDirty=!1,this._worldDirty=!0}updateWorldMatrix(){this._localDirty&&this.updateLocalMatrix(),this._parent?r.mat4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix):r.mat4.copy(this.localMatrix,this._worldMatrix),this._worldDirty=!1;for(const e of this._children)e._worldDirty=!0}makeDirty(){this._localDirty=!0,this._worldDirty=!0;for(const e of this._children)e._worldDirty||e.makeWorldDirty()}makeWorldDirty(){if(!this._worldDirty){this._worldDirty=!0;for(const e of this._children)e.makeWorldDirty()}}get children(){return this._children}add(e){e._parent!==this&&(e._parent&&e._parent.remove(e),-1===this._children.indexOf(e)&&(this._children.push(e),e._parent=this,e.makeWorldDirty()))}remove(e){const t=this._children.indexOf(e);-1!==t&&(this._children.splice(t,1),e._parent=void 0,e.makeWorldDirty())}clear(){for(const e of this._children)e._parent=void 0,e.makeWorldDirty();this._children=[]}traverse(e){e(this);for(const t of this._children)t.traverse(e)}}},599:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.PerspectiveCamera=void 0;const r=n(717),i=n(534);class o extends i.Camera{constructor({fov:e=Math.PI/4,aspect:t=16/9,near:n=.1,far:i=1e3,position:o=r.vec3.create(0,0,10),target:a=r.vec3.create(0,0,0),up:s=r.vec3.create(0,1,0)}={}){super(),this.fov=e,this.aspect=t,this.near=n,this.far=i,this.position=r.vec3.clone(o),this.target=r.vec3.clone(a),this.up=r.vec3.clone(s)}updateProjectionMatrix(){console.log("Updating Projection Matrix using wgpu-matrix"),this._projectionMatrix=r.mat4.perspective(this.fov,this.aspect,this.near,this.far),this._isProjectionDirty=!1}updateViewMatrix(){console.log("Updating View Matrix using wgpu-matrix"),this._viewMatrix=r.mat4.lookAt(this.position,this.target,this.up),this._isViewDirty=!1}setPosition(e,t,n){super.setPosition(e,t,n);const i=r.vec3.create(e,t,n);r.vec3.equals(this.position,i)||(this.position=r.vec3.copy(i,this.position),this._isViewDirty=!0)}setTarget(e){r.vec3.equals(this.target,e)||(this.target=r.vec3.copy(e,this.target),this._isViewDirty=!0)}setUp(e){r.vec3.equals(this.up,e)||(this.up=r.vec3.copy(e,this.up),this._isViewDirty=!0)}setFov(e){this.fov!==e&&(this.fov=e,this._isProjectionDirty=!0)}setAspect(e){this.aspect!==e&&(this.aspect=e,this._isProjectionDirty=!0)}setNear(e){this.near!==e&&(this.near=e,this._isProjectionDirty=!0)}setFar(e){this.far!==e&&(this.far=e,this._isProjectionDirty=!0)}viewportResized(e){this.setAspect(e[0]/e[1])}}t.PerspectiveCamera=o},657:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.BigTriangle=void 0;const r=n(80);class i extends r.Geometry{constructor(e){const t=e.createBuffer(new Float32Array([-1,-1,0,0,0,0,0,1,3,-1,0,2,0,0,0,1,-1,3,0,0,2,0,0,1]),GPUBufferUsage.VERTEX),n=e.createBuffer(new Uint16Array([0,1,2]),GPUBufferUsage.INDEX);super(e,t,n,3,3)}get cacheKey(){return"big-triangle"}get bufferLayout(){return[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}],arrayStride:32,stepMode:"vertex"}]}}t.BigTriangle=i},710:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Color=void 0;const r=n(717);t.Color=class{constructor(e,t,n,r=1){this.r=e,this.g=t,this.b=n,this.a=r}uniformValue(){var e;return null!==(e=this.buffer)&&void 0!==e||(this.buffer=r.vec4.create()),this.buffer.set([this.r,this.g,this.b,this.a]),this.buffer}}},717:(e,t,n)=>{n.r(t),n.d(t,{mat3:()=>x,mat3d:()=>U,mat3n:()=>G,mat4:()=>M,mat4d:()=>T,mat4n:()=>O,quat:()=>w,quatd:()=>D,quatn:()=>E,utils:()=>s,vec2:()=>S,vec2d:()=>A,vec2n:()=>z,vec3:()=>P,vec3d:()=>C,vec3n:()=>I,vec4:()=>B,vec4d:()=>L,vec4n:()=>V});const r=(i=Array,o=e=>e.fill(0),class extends i{constructor(...e){super(...e),o(this)}});var i,o;let a=1e-6;var s={__proto__:null,get EPSILON(){return a},degToRad:function(e){return e*Math.PI/180},euclideanModulo:function(e,t){return(e%t+t)%t},inverseLerp:function(e,t,n){const r=t-e;return Math.abs(t-e)<a?e:(n-e)/r},lerp:function(e,t,n){return e+(t-e)*n},radToDeg:function(e){return 180*e/Math.PI},setEpsilon:function(e){const t=a;return a=e,t}};const u=new Map;function c(e){let t=u.get(e);return t||(t=function(e){function t(t=0,n=0){const r=new e(2);return void 0!==t&&(r[0]=t,void 0!==n&&(r[1]=n)),r}function n(t,n,r){const i=r??new e(2);return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i}function r(t,n,r,i){const o=i??new e(2);return o[0]=t[0]+r*(n[0]-t[0]),o[1]=t[1]+r*(n[1]-t[1]),o}function i(t,n,r){const i=r??new e(2);return i[0]=t[0]*n,i[1]=t[1]*n,i}function o(t,n){const r=n??new e(2);return r[0]=1/t[0],r[1]=1/t[1],r}function s(e,t){return e[0]*t[0]+e[1]*t[1]}function u(e){const t=e[0],n=e[1];return Math.sqrt(t*t+n*n)}function c(e){const t=e[0],n=e[1];return t*t+n*n}function l(e,t){const n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)}function f(e,t){const n=e[0]-t[0],r=e[1]-t[1];return n*n+r*r}function d(t,n){const r=n??new e(2),i=t[0],o=t[1],a=Math.sqrt(i*i+o*o);return a>1e-5?(r[0]=i/a,r[1]=o/a):(r[0]=0,r[1]=0),r}function h(t,n){const r=n??new e(2);return r[0]=t[0],r[1]=t[1],r}function _(t,n,r){const i=r??new e(2);return i[0]=t[0]*n[0],i[1]=t[1]*n[1],i}function m(t,n,r){const i=r??new e(2);return i[0]=t[0]/n[0],i[1]=t[1]/n[1],i}function p(t,n,r){const o=r??new e(2);return d(t,o),i(o,n,o)}return{create:t,fromValues:t,set:function(t,n,r){const i=r??new e(2);return i[0]=t,i[1]=n,i},ceil:function(t,n){const r=n??new e(2);return r[0]=Math.ceil(t[0]),r[1]=Math.ceil(t[1]),r},floor:function(t,n){const r=n??new e(2);return r[0]=Math.floor(t[0]),r[1]=Math.floor(t[1]),r},round:function(t,n){const r=n??new e(2);return r[0]=Math.round(t[0]),r[1]=Math.round(t[1]),r},clamp:function(t,n=0,r=1,i){const o=i??new e(2);return o[0]=Math.min(r,Math.max(n,t[0])),o[1]=Math.min(r,Math.max(n,t[1])),o},add:function(t,n,r){const i=r??new e(2);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i},addScaled:function(t,n,r,i){const o=i??new e(2);return o[0]=t[0]+n[0]*r,o[1]=t[1]+n[1]*r,o},angle:function(e,t){const n=e[0],r=e[1],i=t[0],o=t[1],a=Math.sqrt(n*n+r*r)*Math.sqrt(i*i+o*o),u=a&&s(e,t)/a;return Math.acos(u)},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]},lerp:r,lerpV:function(t,n,r,i){const o=i??new e(2);return o[0]=t[0]+r[0]*(n[0]-t[0]),o[1]=t[1]+r[1]*(n[1]-t[1]),o},max:function(t,n,r){const i=r??new e(2);return i[0]=Math.max(t[0],n[0]),i[1]=Math.max(t[1],n[1]),i},min:function(t,n,r){const i=r??new e(2);return i[0]=Math.min(t[0],n[0]),i[1]=Math.min(t[1],n[1]),i},mulScalar:i,scale:i,divScalar:function(t,n,r){const i=r??new e(2);return i[0]=t[0]/n,i[1]=t[1]/n,i},inverse:o,invert:o,cross:function(t,n,r){const i=r??new e(3),o=t[0]*n[1]-t[1]*n[0];return i[0]=0,i[1]=0,i[2]=o,i},dot:s,length:u,len:u,lengthSq:c,lenSq:c,distance:l,dist:l,distanceSq:f,distSq:f,normalize:d,negate:function(t,n){const r=n??new e(2);return r[0]=-t[0],r[1]=-t[1],r},copy:h,clone:h,multiply:_,mul:_,divide:m,div:m,random:function(t=1,n){const r=n??new e(2),i=2*Math.random()*Math.PI;return r[0]=Math.cos(i)*t,r[1]=Math.sin(i)*t,r},zero:function(t){const n=t??new e(2);return n[0]=0,n[1]=0,n},transformMat4:function(t,n,r){const i=r??new e(2),o=t[0],a=t[1];return i[0]=o*n[0]+a*n[4]+n[12],i[1]=o*n[1]+a*n[5]+n[13],i},transformMat3:function(t,n,r){const i=r??new e(2),o=t[0],a=t[1];return i[0]=n[0]*o+n[4]*a+n[8],i[1]=n[1]*o+n[5]*a+n[9],i},rotate:function(t,n,r,i){const o=i??new e(2),a=t[0]-n[0],s=t[1]-n[1],u=Math.sin(r),c=Math.cos(r);return o[0]=a*c-s*u+n[0],o[1]=a*u+s*c+n[1],o},setLength:p,truncate:function(t,n,r){const i=r??new e(2);return u(t)>n?p(t,n,i):h(t,i)},midpoint:function(t,n,i){return r(t,n,.5,i??new e(2))}}}(e),u.set(e,t)),t}const l=new Map;function f(e){let t=l.get(e);return t||(t=function(e){function t(t,n,r){const i=new e(3);return void 0!==t&&(i[0]=t,void 0!==n&&(i[1]=n,void 0!==r&&(i[2]=r))),i}function n(t,n,r){const i=r??new e(3);return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],i}function r(t,n,r,i){const o=i??new e(3);return o[0]=t[0]+r*(n[0]-t[0]),o[1]=t[1]+r*(n[1]-t[1]),o[2]=t[2]+r*(n[2]-t[2]),o}function i(t,n,r){const i=r??new e(3);return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n,i}function o(t,n){const r=n??new e(3);return r[0]=1/t[0],r[1]=1/t[1],r[2]=1/t[2],r}function s(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function u(e){const t=e[0],n=e[1],r=e[2];return Math.sqrt(t*t+n*n+r*r)}function c(e){const t=e[0],n=e[1],r=e[2];return t*t+n*n+r*r}function l(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return Math.sqrt(n*n+r*r+i*i)}function f(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2];return n*n+r*r+i*i}function d(t,n){const r=n??new e(3),i=t[0],o=t[1],a=t[2],s=Math.sqrt(i*i+o*o+a*a);return s>1e-5?(r[0]=i/s,r[1]=o/s,r[2]=a/s):(r[0]=0,r[1]=0,r[2]=0),r}function h(t,n){const r=n??new e(3);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r}function _(t,n,r){const i=r??new e(3);return i[0]=t[0]*n[0],i[1]=t[1]*n[1],i[2]=t[2]*n[2],i}function m(t,n,r){const i=r??new e(3);return i[0]=t[0]/n[0],i[1]=t[1]/n[1],i[2]=t[2]/n[2],i}function p(t,n,r){const o=r??new e(3);return d(t,o),i(o,n,o)}return{create:t,fromValues:t,set:function(t,n,r,i){const o=i??new e(3);return o[0]=t,o[1]=n,o[2]=r,o},ceil:function(t,n){const r=n??new e(3);return r[0]=Math.ceil(t[0]),r[1]=Math.ceil(t[1]),r[2]=Math.ceil(t[2]),r},floor:function(t,n){const r=n??new e(3);return r[0]=Math.floor(t[0]),r[1]=Math.floor(t[1]),r[2]=Math.floor(t[2]),r},round:function(t,n){const r=n??new e(3);return r[0]=Math.round(t[0]),r[1]=Math.round(t[1]),r[2]=Math.round(t[2]),r},clamp:function(t,n=0,r=1,i){const o=i??new e(3);return o[0]=Math.min(r,Math.max(n,t[0])),o[1]=Math.min(r,Math.max(n,t[1])),o[2]=Math.min(r,Math.max(n,t[2])),o},add:function(t,n,r){const i=r??new e(3);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i[2]=t[2]+n[2],i},addScaled:function(t,n,r,i){const o=i??new e(3);return o[0]=t[0]+n[0]*r,o[1]=t[1]+n[1]*r,o[2]=t[2]+n[2]*r,o},angle:function(e,t){const n=e[0],r=e[1],i=e[2],o=t[0],a=t[1],u=t[2],c=Math.sqrt(n*n+r*r+i*i)*Math.sqrt(o*o+a*a+u*u),l=c&&s(e,t)/c;return Math.acos(l)},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]},lerp:r,lerpV:function(t,n,r,i){const o=i??new e(3);return o[0]=t[0]+r[0]*(n[0]-t[0]),o[1]=t[1]+r[1]*(n[1]-t[1]),o[2]=t[2]+r[2]*(n[2]-t[2]),o},max:function(t,n,r){const i=r??new e(3);return i[0]=Math.max(t[0],n[0]),i[1]=Math.max(t[1],n[1]),i[2]=Math.max(t[2],n[2]),i},min:function(t,n,r){const i=r??new e(3);return i[0]=Math.min(t[0],n[0]),i[1]=Math.min(t[1],n[1]),i[2]=Math.min(t[2],n[2]),i},mulScalar:i,scale:i,divScalar:function(t,n,r){const i=r??new e(3);return i[0]=t[0]/n,i[1]=t[1]/n,i[2]=t[2]/n,i},inverse:o,invert:o,cross:function(t,n,r){const i=r??new e(3),o=t[2]*n[0]-t[0]*n[2],a=t[0]*n[1]-t[1]*n[0];return i[0]=t[1]*n[2]-t[2]*n[1],i[1]=o,i[2]=a,i},dot:s,length:u,len:u,lengthSq:c,lenSq:c,distance:l,dist:l,distanceSq:f,distSq:f,normalize:d,negate:function(t,n){const r=n??new e(3);return r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r},copy:h,clone:h,multiply:_,mul:_,divide:m,div:m,random:function(t=1,n){const r=n??new e(3),i=2*Math.random()*Math.PI,o=2*Math.random()-1,a=Math.sqrt(1-o*o)*t;return r[0]=Math.cos(i)*a,r[1]=Math.sin(i)*a,r[2]=o*t,r},zero:function(t){const n=t??new e(3);return n[0]=0,n[1]=0,n[2]=0,n},transformMat4:function(t,n,r){const i=r??new e(3),o=t[0],a=t[1],s=t[2],u=n[3]*o+n[7]*a+n[11]*s+n[15]||1;return i[0]=(n[0]*o+n[4]*a+n[8]*s+n[12])/u,i[1]=(n[1]*o+n[5]*a+n[9]*s+n[13])/u,i[2]=(n[2]*o+n[6]*a+n[10]*s+n[14])/u,i},transformMat4Upper3x3:function(t,n,r){const i=r??new e(3),o=t[0],a=t[1],s=t[2];return i[0]=o*n[0]+a*n[4]+s*n[8],i[1]=o*n[1]+a*n[5]+s*n[9],i[2]=o*n[2]+a*n[6]+s*n[10],i},transformMat3:function(t,n,r){const i=r??new e(3),o=t[0],a=t[1],s=t[2];return i[0]=o*n[0]+a*n[4]+s*n[8],i[1]=o*n[1]+a*n[5]+s*n[9],i[2]=o*n[2]+a*n[6]+s*n[10],i},transformQuat:function(t,n,r){const i=r??new e(3),o=n[0],a=n[1],s=n[2],u=2*n[3],c=t[0],l=t[1],f=t[2],d=a*f-s*l,h=s*c-o*f,_=o*l-a*c;return i[0]=c+d*u+2*(a*_-s*h),i[1]=l+h*u+2*(s*d-o*_),i[2]=f+_*u+2*(o*h-a*d),i},getTranslation:function(t,n){const r=n??new e(3);return r[0]=t[12],r[1]=t[13],r[2]=t[14],r},getAxis:function(t,n,r){const i=r??new e(3),o=4*n;return i[0]=t[o+0],i[1]=t[o+1],i[2]=t[o+2],i},getScaling:function(t,n){const r=n??new e(3),i=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10];return r[0]=Math.sqrt(i*i+o*o+a*a),r[1]=Math.sqrt(s*s+u*u+c*c),r[2]=Math.sqrt(l*l+f*f+d*d),r},rotateX:function(t,n,r,i){const o=i??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[0],s[1]=a[1]*Math.cos(r)-a[2]*Math.sin(r),s[2]=a[1]*Math.sin(r)+a[2]*Math.cos(r),o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},rotateY:function(t,n,r,i){const o=i??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[2]*Math.sin(r)+a[0]*Math.cos(r),s[1]=a[1],s[2]=a[2]*Math.cos(r)-a[0]*Math.sin(r),o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},rotateZ:function(t,n,r,i){const o=i??new e(3),a=[],s=[];return a[0]=t[0]-n[0],a[1]=t[1]-n[1],a[2]=t[2]-n[2],s[0]=a[0]*Math.cos(r)-a[1]*Math.sin(r),s[1]=a[0]*Math.sin(r)+a[1]*Math.cos(r),s[2]=a[2],o[0]=s[0]+n[0],o[1]=s[1]+n[1],o[2]=s[2]+n[2],o},setLength:p,truncate:function(t,n,r){const i=r??new e(3);return u(t)>n?p(t,n,i):h(t,i)},midpoint:function(t,n,i){return r(t,n,.5,i??new e(3))}}}(e),l.set(e,t)),t}const d=new Map;function h(e){let t=d.get(e);return t||(t=function(e){const t=c(e),n=f(e);function r(t,n,r){const i=r??new e(12);return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n,i[4]=t[4]*n,i[5]=t[5]*n,i[6]=t[6]*n,i[8]=t[8]*n,i[9]=t[9]*n,i[10]=t[10]*n,i}function i(t,n){const r=n??new e(12);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[4]=t[4],r[5]=t[5],r[6]=t[6],r[8]=t[8],r[9]=t[9],r[10]=t[10],r}function o(t){const n=t??new e(12);return n[0]=1,n[1]=0,n[2]=0,n[4]=0,n[5]=1,n[6]=0,n[8]=0,n[9]=0,n[10]=1,n}function s(t,n){const r=n??new e(12),i=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10],h=d*u-c*f,_=-d*s+c*l,m=f*s-u*l,p=1/(i*h+o*_+a*m);return r[0]=h*p,r[1]=(-d*o+a*f)*p,r[2]=(c*o-a*u)*p,r[4]=_*p,r[5]=(d*i-a*l)*p,r[6]=(-c*i+a*s)*p,r[8]=m*p,r[9]=(-f*i+o*l)*p,r[10]=(u*i-o*s)*p,r}function u(t,n,r){const i=r??new e(12),o=t[0],a=t[1],s=t[2],u=t[4],c=t[5],l=t[6],f=t[8],d=t[9],h=t[10],_=n[0],m=n[1],p=n[2],g=n[4],v=n[5],y=n[6],b=n[8],x=n[9],M=n[10];return i[0]=o*_+u*m+f*p,i[1]=a*_+c*m+d*p,i[2]=s*_+l*m+h*p,i[4]=o*g+u*v+f*y,i[5]=a*g+c*v+d*y,i[6]=s*g+l*v+h*y,i[8]=o*b+u*x+f*M,i[9]=a*b+c*x+d*M,i[10]=s*b+l*x+h*M,i}function l(t,n){const r=n??new e(12),i=Math.cos(t),o=Math.sin(t);return r[0]=i,r[1]=o,r[2]=0,r[4]=-o,r[5]=i,r[6]=0,r[8]=0,r[9]=0,r[10]=1,r}function d(t,n,r){const i=r??new e(12),o=t[0],a=t[1],s=t[2],u=t[4],c=t[5],l=t[6],f=Math.cos(n),d=Math.sin(n);return i[0]=f*o+d*u,i[1]=f*a+d*c,i[2]=f*s+d*l,i[4]=f*u-d*o,i[5]=f*c-d*a,i[6]=f*l-d*s,t!==i&&(i[8]=t[8],i[9]=t[9],i[10]=t[10]),i}return{add:function(t,n,r){const i=r??new e(12);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i[2]=t[2]+n[2],i[4]=t[4]+n[4],i[5]=t[5]+n[5],i[6]=t[6]+n[6],i[8]=t[8]+n[8],i[9]=t[9]+n[9],i[10]=t[10]+n[10],i},clone:i,copy:i,create:function(t,n,r,i,o,a,s,u,c){const l=new e(12);return l[3]=0,l[7]=0,l[11]=0,void 0!==t&&(l[0]=t,void 0!==n&&(l[1]=n,void 0!==r&&(l[2]=r,void 0!==i&&(l[4]=i,void 0!==o&&(l[5]=o,void 0!==a&&(l[6]=a,void 0!==s&&(l[8]=s,void 0!==u&&(l[9]=u,void 0!==c&&(l[10]=c))))))))),l},determinant:function(e){const t=e[0],n=e[1],r=e[2],i=e[4],o=e[5],a=e[6],s=e[8],u=e[9],c=e[10];return t*(o*c-u*a)-i*(n*c-u*r)+s*(n*a-o*r)},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]},equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[4]-t[4])<a&&Math.abs(e[5]-t[5])<a&&Math.abs(e[6]-t[6])<a&&Math.abs(e[8]-t[8])<a&&Math.abs(e[9]-t[9])<a&&Math.abs(e[10]-t[10])<a},fromMat4:function(t,n){const r=n??new e(12);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=0,r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=0,r[8]=t[8],r[9]=t[9],r[10]=t[10],r[11]=0,r},fromQuat:function(t,n){const r=n??new e(12),i=t[0],o=t[1],a=t[2],s=t[3],u=i+i,c=o+o,l=a+a,f=i*u,d=o*u,h=o*c,_=a*u,m=a*c,p=a*l,g=s*u,v=s*c,y=s*l;return r[0]=1-h-p,r[1]=d+y,r[2]=_-v,r[3]=0,r[4]=d-y,r[5]=1-f-p,r[6]=m+g,r[7]=0,r[8]=_+v,r[9]=m-g,r[10]=1-f-h,r[11]=0,r},get3DScaling:function(e,t){const r=t??n.create(),i=e[0],o=e[1],a=e[2],s=e[4],u=e[5],c=e[6],l=e[8],f=e[9],d=e[10];return r[0]=Math.sqrt(i*i+o*o+a*a),r[1]=Math.sqrt(s*s+u*u+c*c),r[2]=Math.sqrt(l*l+f*f+d*d),r},getAxis:function(e,n,r){const i=r??t.create(),o=4*n;return i[0]=e[o+0],i[1]=e[o+1],i},getScaling:function(e,n){const r=n??t.create(),i=e[0],o=e[1],a=e[4],s=e[5];return r[0]=Math.sqrt(i*i+o*o),r[1]=Math.sqrt(a*a+s*s),r},getTranslation:function(e,n){const r=n??t.create();return r[0]=e[8],r[1]=e[9],r},identity:o,inverse:s,invert:s,mul:u,mulScalar:r,multiply:u,multiplyScalar:r,negate:function(t,n){const r=n??new e(12);return r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r[4]=-t[4],r[5]=-t[5],r[6]=-t[6],r[8]=-t[8],r[9]=-t[9],r[10]=-t[10],r},rotate:d,rotateX:function(t,n,r){const i=r??new e(12),o=t[4],a=t[5],s=t[6],u=t[8],c=t[9],l=t[10],f=Math.cos(n),d=Math.sin(n);return i[4]=f*o+d*u,i[5]=f*a+d*c,i[6]=f*s+d*l,i[8]=f*u-d*o,i[9]=f*c-d*a,i[10]=f*l-d*s,t!==i&&(i[0]=t[0],i[1]=t[1],i[2]=t[2]),i},rotateY:function(t,n,r){const i=r??new e(12),o=t[0],a=t[1],s=t[2],u=t[8],c=t[9],l=t[10],f=Math.cos(n),d=Math.sin(n);return i[0]=f*o-d*u,i[1]=f*a-d*c,i[2]=f*s-d*l,i[8]=f*u+d*o,i[9]=f*c+d*a,i[10]=f*l+d*s,t!==i&&(i[4]=t[4],i[5]=t[5],i[6]=t[6]),i},rotateZ:d,rotation:l,rotationX:function(t,n){const r=n??new e(12),i=Math.cos(t),o=Math.sin(t);return r[0]=1,r[1]=0,r[2]=0,r[4]=0,r[5]=i,r[6]=o,r[8]=0,r[9]=-o,r[10]=i,r},rotationY:function(t,n){const r=n??new e(12),i=Math.cos(t),o=Math.sin(t);return r[0]=i,r[1]=0,r[2]=-o,r[4]=0,r[5]=1,r[6]=0,r[8]=o,r[9]=0,r[10]=i,r},rotationZ:l,scale:function(t,n,r){const i=r??new e(12),o=n[0],a=n[1];return i[0]=o*t[0],i[1]=o*t[1],i[2]=o*t[2],i[4]=a*t[4],i[5]=a*t[5],i[6]=a*t[6],t!==i&&(i[8]=t[8],i[9]=t[9],i[10]=t[10]),i},scale3D:function(t,n,r){const i=r??new e(12),o=n[0],a=n[1],s=n[2];return i[0]=o*t[0],i[1]=o*t[1],i[2]=o*t[2],i[4]=a*t[4],i[5]=a*t[5],i[6]=a*t[6],i[8]=s*t[8],i[9]=s*t[9],i[10]=s*t[10],i},scaling:function(t,n){const r=n??new e(12);return r[0]=t[0],r[1]=0,r[2]=0,r[4]=0,r[5]=t[1],r[6]=0,r[8]=0,r[9]=0,r[10]=1,r},scaling3D:function(t,n){const r=n??new e(12);return r[0]=t[0],r[1]=0,r[2]=0,r[4]=0,r[5]=t[1],r[6]=0,r[8]=0,r[9]=0,r[10]=t[2],r},set:function(t,n,r,i,o,a,s,u,c,l){const f=l??new e(12);return f[0]=t,f[1]=n,f[2]=r,f[3]=0,f[4]=i,f[5]=o,f[6]=a,f[7]=0,f[8]=s,f[9]=u,f[10]=c,f[11]=0,f},setAxis:function(e,t,n,r){const o=r===e?e:i(e,r),a=4*n;return o[a+0]=t[0],o[a+1]=t[1],o},setTranslation:function(e,t,n){const r=n??o();return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[4]=e[4],r[5]=e[5],r[6]=e[6]),r[8]=t[0],r[9]=t[1],r[10]=1,r},translate:function(t,n,r){const i=r??new e(12),o=n[0],a=n[1],s=t[0],u=t[1],c=t[2],l=t[4],f=t[5],d=t[6],h=t[8],_=t[9],m=t[10];return t!==i&&(i[0]=s,i[1]=u,i[2]=c,i[4]=l,i[5]=f,i[6]=d),i[8]=s*o+l*a+h,i[9]=u*o+f*a+_,i[10]=c*o+d*a+m,i},translation:function(t,n){const r=n??new e(12);return r[0]=1,r[1]=0,r[2]=0,r[4]=0,r[5]=1,r[6]=0,r[8]=t[0],r[9]=t[1],r[10]=1,r},transpose:function(t,n){const r=n??new e(12);if(r===t){let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,r}const i=t[0],o=t[1],a=t[2],s=t[4],u=t[5],c=t[6],l=t[8],f=t[9],d=t[10];return r[0]=i,r[1]=s,r[2]=l,r[4]=o,r[5]=u,r[6]=f,r[8]=a,r[9]=c,r[10]=d,r},uniformScale:function(t,n,r){const i=r??new e(12);return i[0]=n*t[0],i[1]=n*t[1],i[2]=n*t[2],i[4]=n*t[4],i[5]=n*t[5],i[6]=n*t[6],t!==i&&(i[8]=t[8],i[9]=t[9],i[10]=t[10]),i},uniformScale3D:function(t,n,r){const i=r??new e(12);return i[0]=n*t[0],i[1]=n*t[1],i[2]=n*t[2],i[4]=n*t[4],i[5]=n*t[5],i[6]=n*t[6],i[8]=n*t[8],i[9]=n*t[9],i[10]=n*t[10],i},uniformScaling:function(t,n){const r=n??new e(12);return r[0]=t,r[1]=0,r[2]=0,r[4]=0,r[5]=t,r[6]=0,r[8]=0,r[9]=0,r[10]=1,r},uniformScaling3D:function(t,n){const r=n??new e(12);return r[0]=t,r[1]=0,r[2]=0,r[4]=0,r[5]=t,r[6]=0,r[8]=0,r[9]=0,r[10]=t,r}}}(e),d.set(e,t)),t}const _=new Map;function m(e){let t=_.get(e);return t||(t=function(e){const t=f(e);function n(t,n,r){const i=r??new e(16);return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n,i[3]=t[3]*n,i[4]=t[4]*n,i[5]=t[5]*n,i[6]=t[6]*n,i[7]=t[7]*n,i[8]=t[8]*n,i[9]=t[9]*n,i[10]=t[10]*n,i[11]=t[11]*n,i[12]=t[12]*n,i[13]=t[13]*n,i[14]=t[14]*n,i[15]=t[15]*n,i}const r=n;function i(t,n){const r=n??new e(16);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=t[7],r[8]=t[8],r[9]=t[9],r[10]=t[10],r[11]=t[11],r[12]=t[12],r[13]=t[13],r[14]=t[14],r[15]=t[15],r}const o=i;function s(t){const n=t??new e(16);return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function u(t,n){const r=n??new e(16),i=t[0],o=t[1],a=t[2],s=t[3],u=t[4],c=t[5],l=t[6],f=t[7],d=t[8],h=t[9],_=t[10],m=t[11],p=t[12],g=t[13],v=t[14],y=t[15],b=_*y,x=v*m,M=l*y,w=v*f,S=l*m,P=_*f,B=a*y,U=v*s,T=a*m,D=_*s,A=a*f,C=l*s,L=d*g,G=p*h,O=u*g,E=p*c,z=u*h,I=d*c,V=i*g,j=p*o,F=i*h,N=d*o,R=i*c,q=u*o,k=b*c+w*h+S*g-(x*c+M*h+P*g),$=x*o+B*h+D*g-(b*o+U*h+T*g),Y=M*o+U*c+A*g-(w*o+B*c+C*g),H=P*o+T*c+C*h-(S*o+D*c+A*h),K=1/(i*k+u*$+d*Y+p*H);return r[0]=K*k,r[1]=K*$,r[2]=K*Y,r[3]=K*H,r[4]=K*(x*u+M*d+P*p-(b*u+w*d+S*p)),r[5]=K*(b*i+U*d+T*p-(x*i+B*d+D*p)),r[6]=K*(w*i+B*u+C*p-(M*i+U*u+A*p)),r[7]=K*(S*i+D*u+A*d-(P*i+T*u+C*d)),r[8]=K*(L*f+E*m+z*y-(G*f+O*m+I*y)),r[9]=K*(G*s+V*m+N*y-(L*s+j*m+F*y)),r[10]=K*(O*s+j*f+R*y-(E*s+V*f+q*y)),r[11]=K*(I*s+F*f+q*m-(z*s+N*f+R*m)),r[12]=K*(O*_+I*v+G*l-(z*v+L*l+E*_)),r[13]=K*(F*v+L*a+j*_-(V*_+N*v+G*a)),r[14]=K*(V*l+q*v+E*a-(R*v+O*a+j*l)),r[15]=K*(R*_+z*a+N*l-(F*l+q*_+I*a)),r}const c=u;function l(t,n,r){const i=r??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[4],l=t[5],f=t[6],d=t[7],h=t[8],_=t[9],m=t[10],p=t[11],g=t[12],v=t[13],y=t[14],b=t[15],x=n[0],M=n[1],w=n[2],S=n[3],P=n[4],B=n[5],U=n[6],T=n[7],D=n[8],A=n[9],C=n[10],L=n[11],G=n[12],O=n[13],E=n[14],z=n[15];return i[0]=o*x+c*M+h*w+g*S,i[1]=a*x+l*M+_*w+v*S,i[2]=s*x+f*M+m*w+y*S,i[3]=u*x+d*M+p*w+b*S,i[4]=o*P+c*B+h*U+g*T,i[5]=a*P+l*B+_*U+v*T,i[6]=s*P+f*B+m*U+y*T,i[7]=u*P+d*B+p*U+b*T,i[8]=o*D+c*A+h*C+g*L,i[9]=a*D+l*A+_*C+v*L,i[10]=s*D+f*A+m*C+y*L,i[11]=u*D+d*A+p*C+b*L,i[12]=o*G+c*O+h*E+g*z,i[13]=a*G+l*O+_*E+v*z,i[14]=s*G+f*O+m*E+y*z,i[15]=u*G+d*O+p*E+b*z,i}const d=l,h=t.create(),_=t.create(),m=t.create();function p(t,n,r){const i=r??new e(16);let o=t[0],a=t[1],s=t[2];const u=Math.sqrt(o*o+a*a+s*s);o/=u,a/=u,s/=u;const c=o*o,l=a*a,f=s*s,d=Math.cos(n),h=Math.sin(n),_=1-d;return i[0]=c+(1-c)*d,i[1]=o*a*_+s*h,i[2]=o*s*_-a*h,i[3]=0,i[4]=o*a*_-s*h,i[5]=l+(1-l)*d,i[6]=a*s*_+o*h,i[7]=0,i[8]=o*s*_+a*h,i[9]=a*s*_-o*h,i[10]=f+(1-f)*d,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function g(t,n,r,i){const o=i??new e(16);let a=n[0],s=n[1],u=n[2];const c=Math.sqrt(a*a+s*s+u*u);a/=c,s/=c,u/=c;const l=a*a,f=s*s,d=u*u,h=Math.cos(r),_=Math.sin(r),m=1-h,p=l+(1-l)*h,g=a*s*m+u*_,v=a*u*m-s*_,y=a*s*m-u*_,b=f+(1-f)*h,x=s*u*m+a*_,M=a*u*m+s*_,w=s*u*m-a*_,S=d+(1-d)*h,P=t[0],B=t[1],U=t[2],T=t[3],D=t[4],A=t[5],C=t[6],L=t[7],G=t[8],O=t[9],E=t[10],z=t[11];return o[0]=p*P+g*D+v*G,o[1]=p*B+g*A+v*O,o[2]=p*U+g*C+v*E,o[3]=p*T+g*L+v*z,o[4]=y*P+b*D+x*G,o[5]=y*B+b*A+x*O,o[6]=y*U+b*C+x*E,o[7]=y*T+b*L+x*z,o[8]=M*P+w*D+S*G,o[9]=M*B+w*A+S*O,o[10]=M*U+w*C+S*E,o[11]=M*T+w*L+S*z,t!==o&&(o[12]=t[12],o[13]=t[13],o[14]=t[14],o[15]=t[15]),o}return{add:function(t,n,r){const i=r??new e(16);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i[2]=t[2]+n[2],i[3]=t[3]+n[3],i[4]=t[4]+n[4],i[5]=t[5]+n[5],i[6]=t[6]+n[6],i[7]=t[7]+n[7],i[8]=t[8]+n[8],i[9]=t[9]+n[9],i[10]=t[10]+n[10],i[11]=t[11]+n[11],i[12]=t[12]+n[12],i[13]=t[13]+n[13],i[14]=t[14]+n[14],i[15]=t[15]+n[15],i},aim:function(n,r,i,o){const a=o??new e(16);return t.normalize(t.subtract(r,n,m),m),t.normalize(t.cross(i,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=h[1],a[2]=h[2],a[3]=0,a[4]=_[0],a[5]=_[1],a[6]=_[2],a[7]=0,a[8]=m[0],a[9]=m[1],a[10]=m[2],a[11]=0,a[12]=n[0],a[13]=n[1],a[14]=n[2],a[15]=1,a},axisRotate:g,axisRotation:p,cameraAim:function(n,r,i,o){const a=o??new e(16);return t.normalize(t.subtract(n,r,m),m),t.normalize(t.cross(i,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=h[1],a[2]=h[2],a[3]=0,a[4]=_[0],a[5]=_[1],a[6]=_[2],a[7]=0,a[8]=m[0],a[9]=m[1],a[10]=m[2],a[11]=0,a[12]=n[0],a[13]=n[1],a[14]=n[2],a[15]=1,a},clone:o,copy:i,create:function(t,n,r,i,o,a,s,u,c,l,f,d,h,_,m,p){const g=new e(16);return void 0!==t&&(g[0]=t,void 0!==n&&(g[1]=n,void 0!==r&&(g[2]=r,void 0!==i&&(g[3]=i,void 0!==o&&(g[4]=o,void 0!==a&&(g[5]=a,void 0!==s&&(g[6]=s,void 0!==u&&(g[7]=u,void 0!==c&&(g[8]=c,void 0!==l&&(g[9]=l,void 0!==f&&(g[10]=f,void 0!==d&&(g[11]=d,void 0!==h&&(g[12]=h,void 0!==_&&(g[13]=_,void 0!==m&&(g[14]=m,void 0!==p&&(g[15]=p)))))))))))))))),g},determinant:function(e){const t=e[0],n=e[1],r=e[2],i=e[3],o=e[4],a=e[5],s=e[6],u=e[7],c=e[8],l=e[9],f=e[10],d=e[11],h=e[12],_=e[13],m=e[14],p=e[15],g=f*p,v=m*d,y=s*p,b=m*u,x=s*d,M=f*u,w=r*p,S=m*i,P=r*d,B=f*i,U=r*u,T=s*i;return t*(g*a+b*l+x*_-(v*a+y*l+M*_))+o*(v*n+w*l+B*_-(g*n+S*l+P*_))+c*(y*n+S*a+U*_-(b*n+w*a+T*_))+h*(M*n+P*a+T*l-(x*n+B*a+U*l))},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]},equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a&&Math.abs(e[4]-t[4])<a&&Math.abs(e[5]-t[5])<a&&Math.abs(e[6]-t[6])<a&&Math.abs(e[7]-t[7])<a&&Math.abs(e[8]-t[8])<a&&Math.abs(e[9]-t[9])<a&&Math.abs(e[10]-t[10])<a&&Math.abs(e[11]-t[11])<a&&Math.abs(e[12]-t[12])<a&&Math.abs(e[13]-t[13])<a&&Math.abs(e[14]-t[14])<a&&Math.abs(e[15]-t[15])<a},fromMat3:function(t,n){const r=n??new e(16);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=0,r[4]=t[4],r[5]=t[5],r[6]=t[6],r[7]=0,r[8]=t[8],r[9]=t[9],r[10]=t[10],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},fromQuat:function(t,n){const r=n??new e(16),i=t[0],o=t[1],a=t[2],s=t[3],u=i+i,c=o+o,l=a+a,f=i*u,d=o*u,h=o*c,_=a*u,m=a*c,p=a*l,g=s*u,v=s*c,y=s*l;return r[0]=1-h-p,r[1]=d+y,r[2]=_-v,r[3]=0,r[4]=d-y,r[5]=1-f-p,r[6]=m+g,r[7]=0,r[8]=_+v,r[9]=m-g,r[10]=1-f-h,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},frustum:function(t,n,r,i,o,a,s){const u=s??new e(16),c=n-t,l=i-r,f=o-a;return u[0]=2*o/c,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2*o/l,u[6]=0,u[7]=0,u[8]=(t+n)/c,u[9]=(i+r)/l,u[10]=a/f,u[11]=-1,u[12]=0,u[13]=0,u[14]=o*a/f,u[15]=0,u},frustumReverseZ:function(t,n,r,i,o,a=1/0,s){const u=s??new e(16),c=n-t,l=i-r;if(u[0]=2*o/c,u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2*o/l,u[6]=0,u[7]=0,u[8]=(t+n)/c,u[9]=(i+r)/l,u[11]=-1,u[12]=0,u[13]=0,u[15]=0,a===1/0)u[10]=0,u[14]=o;else{const e=1/(a-o);u[10]=o*e,u[14]=a*o*e}return u},getAxis:function(e,n,r){const i=r??t.create(),o=4*n;return i[0]=e[o+0],i[1]=e[o+1],i[2]=e[o+2],i},getScaling:function(e,n){const r=n??t.create(),i=e[0],o=e[1],a=e[2],s=e[4],u=e[5],c=e[6],l=e[8],f=e[9],d=e[10];return r[0]=Math.sqrt(i*i+o*o+a*a),r[1]=Math.sqrt(s*s+u*u+c*c),r[2]=Math.sqrt(l*l+f*f+d*d),r},getTranslation:function(e,n){const r=n??t.create();return r[0]=e[12],r[1]=e[13],r[2]=e[14],r},identity:s,inverse:u,invert:c,lookAt:function(n,r,i,o){const a=o??new e(16);return t.normalize(t.subtract(n,r,m),m),t.normalize(t.cross(i,m,h),h),t.normalize(t.cross(m,h,_),_),a[0]=h[0],a[1]=_[0],a[2]=m[0],a[3]=0,a[4]=h[1],a[5]=_[1],a[6]=m[1],a[7]=0,a[8]=h[2],a[9]=_[2],a[10]=m[2],a[11]=0,a[12]=-(h[0]*n[0]+h[1]*n[1]+h[2]*n[2]),a[13]=-(_[0]*n[0]+_[1]*n[1]+_[2]*n[2]),a[14]=-(m[0]*n[0]+m[1]*n[1]+m[2]*n[2]),a[15]=1,a},mul:d,mulScalar:r,multiply:l,multiplyScalar:n,negate:function(t,n){const r=n??new e(16);return r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r[3]=-t[3],r[4]=-t[4],r[5]=-t[5],r[6]=-t[6],r[7]=-t[7],r[8]=-t[8],r[9]=-t[9],r[10]=-t[10],r[11]=-t[11],r[12]=-t[12],r[13]=-t[13],r[14]=-t[14],r[15]=-t[15],r},ortho:function(t,n,r,i,o,a,s){const u=s??new e(16);return u[0]=2/(n-t),u[1]=0,u[2]=0,u[3]=0,u[4]=0,u[5]=2/(i-r),u[6]=0,u[7]=0,u[8]=0,u[9]=0,u[10]=1/(o-a),u[11]=0,u[12]=(n+t)/(t-n),u[13]=(i+r)/(r-i),u[14]=o/(o-a),u[15]=1,u},perspective:function(t,n,r,i,o){const a=o??new e(16),s=Math.tan(.5*Math.PI-.5*t);if(a[0]=s/n,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=s,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,Number.isFinite(i)){const e=1/(r-i);a[10]=i*e,a[14]=i*r*e}else a[10]=-1,a[14]=-r;return a},perspectiveReverseZ:function(t,n,r,i=1/0,o){const a=o??new e(16),s=1/Math.tan(.5*t);if(a[0]=s/n,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=s,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,i===1/0)a[10]=0,a[14]=r;else{const e=1/(i-r);a[10]=r*e,a[14]=i*r*e}return a},rotate:g,rotateX:function(t,n,r){const i=r??new e(16),o=t[4],a=t[5],s=t[6],u=t[7],c=t[8],l=t[9],f=t[10],d=t[11],h=Math.cos(n),_=Math.sin(n);return i[4]=h*o+_*c,i[5]=h*a+_*l,i[6]=h*s+_*f,i[7]=h*u+_*d,i[8]=h*c-_*o,i[9]=h*l-_*a,i[10]=h*f-_*s,i[11]=h*d-_*u,t!==i&&(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i},rotateY:function(t,n,r){const i=r??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[8],l=t[9],f=t[10],d=t[11],h=Math.cos(n),_=Math.sin(n);return i[0]=h*o-_*c,i[1]=h*a-_*l,i[2]=h*s-_*f,i[3]=h*u-_*d,i[8]=h*c+_*o,i[9]=h*l+_*a,i[10]=h*f+_*s,i[11]=h*d+_*u,t!==i&&(i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i},rotateZ:function(t,n,r){const i=r??new e(16),o=t[0],a=t[1],s=t[2],u=t[3],c=t[4],l=t[5],f=t[6],d=t[7],h=Math.cos(n),_=Math.sin(n);return i[0]=h*o+_*c,i[1]=h*a+_*l,i[2]=h*s+_*f,i[3]=h*u+_*d,i[4]=h*c-_*o,i[5]=h*l-_*a,i[6]=h*f-_*s,i[7]=h*d-_*u,t!==i&&(i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i},rotation:p,rotationX:function(t,n){const r=n??new e(16),i=Math.cos(t),o=Math.sin(t);return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i,r[6]=o,r[7]=0,r[8]=0,r[9]=-o,r[10]=i,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},rotationY:function(t,n){const r=n??new e(16),i=Math.cos(t),o=Math.sin(t);return r[0]=i,r[1]=0,r[2]=-o,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=o,r[9]=0,r[10]=i,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},rotationZ:function(t,n){const r=n??new e(16),i=Math.cos(t),o=Math.sin(t);return r[0]=i,r[1]=o,r[2]=0,r[3]=0,r[4]=-o,r[5]=i,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},scale:function(t,n,r){const i=r??new e(16),o=n[0],a=n[1],s=n[2];return i[0]=o*t[0],i[1]=o*t[1],i[2]=o*t[2],i[3]=o*t[3],i[4]=a*t[4],i[5]=a*t[5],i[6]=a*t[6],i[7]=a*t[7],i[8]=s*t[8],i[9]=s*t[9],i[10]=s*t[10],i[11]=s*t[11],t!==i&&(i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i},scaling:function(t,n){const r=n??new e(16);return r[0]=t[0],r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=t[1],r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=t[2],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r},set:function(t,n,r,i,o,a,s,u,c,l,f,d,h,_,m,p,g){const v=g??new e(16);return v[0]=t,v[1]=n,v[2]=r,v[3]=i,v[4]=o,v[5]=a,v[6]=s,v[7]=u,v[8]=c,v[9]=l,v[10]=f,v[11]=d,v[12]=h,v[13]=_,v[14]=m,v[15]=p,v},setAxis:function(e,t,n,r){const o=r===e?r:i(e,r),a=4*n;return o[a+0]=t[0],o[a+1]=t[1],o[a+2]=t[2],o},setTranslation:function(e,t,n){const r=n??s();return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11]),r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r},translate:function(t,n,r){const i=r??new e(16),o=n[0],a=n[1],s=n[2],u=t[0],c=t[1],l=t[2],f=t[3],d=t[4],h=t[5],_=t[6],m=t[7],p=t[8],g=t[9],v=t[10],y=t[11],b=t[12],x=t[13],M=t[14],w=t[15];return t!==i&&(i[0]=u,i[1]=c,i[2]=l,i[3]=f,i[4]=d,i[5]=h,i[6]=_,i[7]=m,i[8]=p,i[9]=g,i[10]=v,i[11]=y),i[12]=u*o+d*a+p*s+b,i[13]=c*o+h*a+g*s+x,i[14]=l*o+_*a+v*s+M,i[15]=f*o+m*a+y*s+w,i},translation:function(t,n){const r=n??new e(16);return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r},transpose:function(t,n){const r=n??new e(16);if(r===t){let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,r}const i=t[0],o=t[1],a=t[2],s=t[3],u=t[4],c=t[5],l=t[6],f=t[7],d=t[8],h=t[9],_=t[10],m=t[11],p=t[12],g=t[13],v=t[14],y=t[15];return r[0]=i,r[1]=u,r[2]=d,r[3]=p,r[4]=o,r[5]=c,r[6]=h,r[7]=g,r[8]=a,r[9]=l,r[10]=_,r[11]=v,r[12]=s,r[13]=f,r[14]=m,r[15]=y,r},uniformScale:function(t,n,r){const i=r??new e(16);return i[0]=n*t[0],i[1]=n*t[1],i[2]=n*t[2],i[3]=n*t[3],i[4]=n*t[4],i[5]=n*t[5],i[6]=n*t[6],i[7]=n*t[7],i[8]=n*t[8],i[9]=n*t[9],i[10]=n*t[10],i[11]=n*t[11],t!==i&&(i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]),i},uniformScaling:function(t,n){const r=n??new e(16);return r[0]=t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=t,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}}}(e),_.set(e,t)),t}const p=new Map;function g(e){let t=p.get(e);return t||(t=function(e){const t=f(e);function n(t,n,r,i){const o=new e(4);return void 0!==t&&(o[0]=t,void 0!==n&&(o[1]=n,void 0!==r&&(o[2]=r,void 0!==i&&(o[3]=i)))),o}const r=n;function i(t,n,r){const i=r??new e(4),o=.5*n,a=Math.sin(o);return i[0]=a*t[0],i[1]=a*t[1],i[2]=a*t[2],i[3]=Math.cos(o),i}function o(t,n,r){const i=r??new e(4),o=t[0],a=t[1],s=t[2],u=t[3],c=n[0],l=n[1],f=n[2],d=n[3];return i[0]=o*d+u*c+a*f-s*l,i[1]=a*d+u*l+s*c-o*f,i[2]=s*d+u*f+o*l-a*c,i[3]=u*d-o*c-a*l-s*f,i}const s=o;function u(t,n,r,i){const o=i??new e(4),s=t[0],u=t[1],c=t[2],l=t[3];let f,d,h=n[0],_=n[1],m=n[2],p=n[3],g=s*h+u*_+c*m+l*p;if(g<0&&(g=-g,h=-h,_=-_,m=-m,p=-p),1-g>a){const e=Math.acos(g),t=Math.sin(e);f=Math.sin((1-r)*e)/t,d=Math.sin(r*e)/t}else f=1-r,d=r;return o[0]=f*s+d*h,o[1]=f*u+d*_,o[2]=f*c+d*m,o[3]=f*l+d*p,o}function c(t,n){const r=n??new e(4);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r}const l=c;function d(t,n,r){const i=r??new e(4);return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],i[3]=t[3]-n[3],i}const h=d;function _(t,n,r){const i=r??new e(4);return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n,i[3]=t[3]*n,i}const m=_;function p(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function g(e){const t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)}const v=g;function y(e){const t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i}const b=y;function x(t,n){const r=n??new e(4),i=t[0],o=t[1],a=t[2],s=t[3],u=Math.sqrt(i*i+o*o+a*a+s*s);return u>1e-5?(r[0]=i/u,r[1]=o/u,r[2]=a/u,r[3]=s/u):(r[0]=0,r[1]=0,r[2]=0,r[3]=1),r}const M=t.create(),w=t.create(),S=t.create(),P=new e(4),B=new e(4);return{create:n,fromValues:r,set:function(t,n,r,i,o){const a=o??new e(4);return a[0]=t,a[1]=n,a[2]=r,a[3]=i,a},fromAxisAngle:i,toAxisAngle:function(e,n){const r=n??t.create(3),i=2*Math.acos(e[3]),o=Math.sin(.5*i);return o>a?(r[0]=e[0]/o,r[1]=e[1]/o,r[2]=e[2]/o):(r[0]=1,r[1]=0,r[2]=0),{angle:i,axis:r}},angle:function(e,t){const n=p(e,t);return Math.acos(2*n*n-1)},multiply:o,mul:s,rotateX:function(t,n,r){const i=r??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return i[0]=a*f+c*l,i[1]=s*f+u*l,i[2]=u*f-s*l,i[3]=c*f-a*l,i},rotateY:function(t,n,r){const i=r??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return i[0]=a*f-u*l,i[1]=s*f+c*l,i[2]=u*f+a*l,i[3]=c*f-s*l,i},rotateZ:function(t,n,r){const i=r??new e(4),o=.5*n,a=t[0],s=t[1],u=t[2],c=t[3],l=Math.sin(o),f=Math.cos(o);return i[0]=a*f+s*l,i[1]=s*f-a*l,i[2]=u*f+c*l,i[3]=c*f-u*l,i},slerp:u,inverse:function(t,n){const r=n??new e(4),i=t[0],o=t[1],a=t[2],s=t[3],u=i*i+o*o+a*a+s*s,c=u?1/u:0;return r[0]=-i*c,r[1]=-o*c,r[2]=-a*c,r[3]=s*c,r},conjugate:function(t,n){const r=n??new e(4);return r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r[3]=t[3],r},fromMat:function(t,n){const r=n??new e(4),i=t[0]+t[5]+t[10];if(i>0){const e=Math.sqrt(i+1);r[3]=.5*e;const n=.5/e;r[0]=(t[6]-t[9])*n,r[1]=(t[8]-t[2])*n,r[2]=(t[1]-t[4])*n}else{let e=0;t[5]>t[0]&&(e=1),t[10]>t[4*e+e]&&(e=2);const n=(e+1)%3,i=(e+2)%3,o=Math.sqrt(t[4*e+e]-t[4*n+n]-t[4*i+i]+1);r[e]=.5*o;const a=.5/o;r[3]=(t[4*n+i]-t[4*i+n])*a,r[n]=(t[4*n+e]+t[4*e+n])*a,r[i]=(t[4*i+e]+t[4*e+i])*a}return r},fromEuler:function(t,n,r,i,o){const a=o??new e(4),s=.5*t,u=.5*n,c=.5*r,l=Math.sin(s),f=Math.cos(s),d=Math.sin(u),h=Math.cos(u),_=Math.sin(c),m=Math.cos(c);switch(i){case"xyz":a[0]=l*h*m+f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m-l*d*_;break;case"xzy":a[0]=l*h*m-f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m+l*d*_;break;case"yxz":a[0]=l*h*m+f*d*_,a[1]=f*d*m-l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m+l*d*_;break;case"yzx":a[0]=l*h*m+f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m-l*d*_;break;case"zxy":a[0]=l*h*m-f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_+l*d*m,a[3]=f*h*m-l*d*_;break;case"zyx":a[0]=l*h*m-f*d*_,a[1]=f*d*m+l*h*_,a[2]=f*h*_-l*d*m,a[3]=f*h*m+l*d*_;break;default:throw new Error(`Unknown rotation order: ${i}`)}return a},copy:c,clone:l,add:function(t,n,r){const i=r??new e(4);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i[2]=t[2]+n[2],i[3]=t[3]+n[3],i},subtract:d,sub:h,mulScalar:_,scale:m,divScalar:function(t,n,r){const i=r??new e(4);return i[0]=t[0]/n,i[1]=t[1]/n,i[2]=t[2]/n,i[3]=t[3]/n,i},dot:p,lerp:function(t,n,r,i){const o=i??new e(4);return o[0]=t[0]+r*(n[0]-t[0]),o[1]=t[1]+r*(n[1]-t[1]),o[2]=t[2]+r*(n[2]-t[2]),o[3]=t[3]+r*(n[3]-t[3]),o},length:g,len:v,lengthSq:y,lenSq:b,normalize:x,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},identity:function(t){const n=t??new e(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=1,n},rotationTo:function(n,r,o){const a=o??new e(4),s=t.dot(n,r);return s<-.999999?(t.cross(w,n,M),t.len(M)<1e-6&&t.cross(S,n,M),t.normalize(M,M),i(M,Math.PI,a),a):s>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(t.cross(n,r,M),a[0]=M[0],a[1]=M[1],a[2]=M[2],a[3]=1+s,x(a,a))},sqlerp:function(t,n,r,i,o,a){const s=a??new e(4);return u(t,i,o,P),u(n,r,o,B),u(P,B,2*o*(1-o),s),s}}}(e),p.set(e,t)),t}const v=new Map;function y(e){let t=v.get(e);return t||(t=function(e){function t(t,n,r,i){const o=new e(4);return void 0!==t&&(o[0]=t,void 0!==n&&(o[1]=n,void 0!==r&&(o[2]=r,void 0!==i&&(o[3]=i)))),o}function n(t,n,r){const i=r??new e(4);return i[0]=t[0]-n[0],i[1]=t[1]-n[1],i[2]=t[2]-n[2],i[3]=t[3]-n[3],i}function r(t,n,r,i){const o=i??new e(4);return o[0]=t[0]+r*(n[0]-t[0]),o[1]=t[1]+r*(n[1]-t[1]),o[2]=t[2]+r*(n[2]-t[2]),o[3]=t[3]+r*(n[3]-t[3]),o}function i(t,n,r){const i=r??new e(4);return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*n,i[3]=t[3]*n,i}function o(t,n){const r=n??new e(4);return r[0]=1/t[0],r[1]=1/t[1],r[2]=1/t[2],r[3]=1/t[3],r}function s(e){const t=e[0],n=e[1],r=e[2],i=e[3];return Math.sqrt(t*t+n*n+r*r+i*i)}function u(e){const t=e[0],n=e[1],r=e[2],i=e[3];return t*t+n*n+r*r+i*i}function c(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return Math.sqrt(n*n+r*r+i*i+o*o)}function l(e,t){const n=e[0]-t[0],r=e[1]-t[1],i=e[2]-t[2],o=e[3]-t[3];return n*n+r*r+i*i+o*o}function f(t,n){const r=n??new e(4),i=t[0],o=t[1],a=t[2],s=t[3],u=Math.sqrt(i*i+o*o+a*a+s*s);return u>1e-5?(r[0]=i/u,r[1]=o/u,r[2]=a/u,r[3]=s/u):(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function d(t,n){const r=n??new e(4);return r[0]=t[0],r[1]=t[1],r[2]=t[2],r[3]=t[3],r}function h(t,n,r){const i=r??new e(4);return i[0]=t[0]*n[0],i[1]=t[1]*n[1],i[2]=t[2]*n[2],i[3]=t[3]*n[3],i}function _(t,n,r){const i=r??new e(4);return i[0]=t[0]/n[0],i[1]=t[1]/n[1],i[2]=t[2]/n[2],i[3]=t[3]/n[3],i}function m(t,n,r){const o=r??new e(4);return f(t,o),i(o,n,o)}return{create:t,fromValues:t,set:function(t,n,r,i,o){const a=o??new e(4);return a[0]=t,a[1]=n,a[2]=r,a[3]=i,a},ceil:function(t,n){const r=n??new e(4);return r[0]=Math.ceil(t[0]),r[1]=Math.ceil(t[1]),r[2]=Math.ceil(t[2]),r[3]=Math.ceil(t[3]),r},floor:function(t,n){const r=n??new e(4);return r[0]=Math.floor(t[0]),r[1]=Math.floor(t[1]),r[2]=Math.floor(t[2]),r[3]=Math.floor(t[3]),r},round:function(t,n){const r=n??new e(4);return r[0]=Math.round(t[0]),r[1]=Math.round(t[1]),r[2]=Math.round(t[2]),r[3]=Math.round(t[3]),r},clamp:function(t,n=0,r=1,i){const o=i??new e(4);return o[0]=Math.min(r,Math.max(n,t[0])),o[1]=Math.min(r,Math.max(n,t[1])),o[2]=Math.min(r,Math.max(n,t[2])),o[3]=Math.min(r,Math.max(n,t[3])),o},add:function(t,n,r){const i=r??new e(4);return i[0]=t[0]+n[0],i[1]=t[1]+n[1],i[2]=t[2]+n[2],i[3]=t[3]+n[3],i},addScaled:function(t,n,r,i){const o=i??new e(4);return o[0]=t[0]+n[0]*r,o[1]=t[1]+n[1]*r,o[2]=t[2]+n[2]*r,o[3]=t[3]+n[3]*r,o},subtract:n,sub:n,equalsApproximately:function(e,t){return Math.abs(e[0]-t[0])<a&&Math.abs(e[1]-t[1])<a&&Math.abs(e[2]-t[2])<a&&Math.abs(e[3]-t[3])<a},equals:function(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]},lerp:r,lerpV:function(t,n,r,i){const o=i??new e(4);return o[0]=t[0]+r[0]*(n[0]-t[0]),o[1]=t[1]+r[1]*(n[1]-t[1]),o[2]=t[2]+r[2]*(n[2]-t[2]),o[3]=t[3]+r[3]*(n[3]-t[3]),o},max:function(t,n,r){const i=r??new e(4);return i[0]=Math.max(t[0],n[0]),i[1]=Math.max(t[1],n[1]),i[2]=Math.max(t[2],n[2]),i[3]=Math.max(t[3],n[3]),i},min:function(t,n,r){const i=r??new e(4);return i[0]=Math.min(t[0],n[0]),i[1]=Math.min(t[1],n[1]),i[2]=Math.min(t[2],n[2]),i[3]=Math.min(t[3],n[3]),i},mulScalar:i,scale:i,divScalar:function(t,n,r){const i=r??new e(4);return i[0]=t[0]/n,i[1]=t[1]/n,i[2]=t[2]/n,i[3]=t[3]/n,i},inverse:o,invert:o,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]},length:s,len:s,lengthSq:u,lenSq:u,distance:c,dist:c,distanceSq:l,distSq:l,normalize:f,negate:function(t,n){const r=n??new e(4);return r[0]=-t[0],r[1]=-t[1],r[2]=-t[2],r[3]=-t[3],r},copy:d,clone:d,multiply:h,mul:h,divide:_,div:_,zero:function(t){const n=t??new e(4);return n[0]=0,n[1]=0,n[2]=0,n[3]=0,n},transformMat4:function(t,n,r){const i=r??new e(4),o=t[0],a=t[1],s=t[2],u=t[3];return i[0]=n[0]*o+n[4]*a+n[8]*s+n[12]*u,i[1]=n[1]*o+n[5]*a+n[9]*s+n[13]*u,i[2]=n[2]*o+n[6]*a+n[10]*s+n[14]*u,i[3]=n[3]*o+n[7]*a+n[11]*s+n[15]*u,i},setLength:m,truncate:function(t,n,r){const i=r??new e(4);return s(t)>n?m(t,n,i):d(t,i)},midpoint:function(t,n,i){return r(t,n,.5,i??new e(4))}}}(e),v.set(e,t)),t}function b(e,t,n,r,i,o){return{mat3:h(e),mat4:m(t),quat:g(n),vec2:c(r),vec3:f(i),vec4:y(o)}}const{mat3:x,mat4:M,quat:w,vec2:S,vec3:P,vec4:B}=b(Float32Array,Float32Array,Float32Array,Float32Array,Float32Array,Float32Array),{mat3:U,mat4:T,quat:D,vec2:A,vec3:C,vec4:L}=b(Float64Array,Float64Array,Float64Array,Float64Array,Float64Array,Float64Array),{mat3:G,mat4:O,quat:E,vec2:z,vec3:I,vec4:V}=b(r,Array,Array,Array,Array,Array)},722:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Geometry=t.TetrahedronGeometry=t.SphereGeometry=t.BigTriangle=t.CubeGeometry=void 0;var r=n(161);Object.defineProperty(t,"CubeGeometry",{enumerable:!0,get:function(){return r.CubeGeometry}});var i=n(657);Object.defineProperty(t,"BigTriangle",{enumerable:!0,get:function(){return i.BigTriangle}});var o=n(857);Object.defineProperty(t,"SphereGeometry",{enumerable:!0,get:function(){return o.SphereGeometry}});var a=n(286);Object.defineProperty(t,"TetrahedronGeometry",{enumerable:!0,get:function(){return a.TetrahedronGeometry}});var s=n(80);Object.defineProperty(t,"Geometry",{enumerable:!0,get:function(){return s.Geometry}})},760:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.UVMaterial=t.ShaderMaterial=t.BlinnPhongMaterial=t.BasicMaterial=t.Material=void 0;var r=n(35);Object.defineProperty(t,"Material",{enumerable:!0,get:function(){return r.Material}});var i=n(838);Object.defineProperty(t,"BasicMaterial",{enumerable:!0,get:function(){return i.BasicMaterial}});var o=n(342);Object.defineProperty(t,"BlinnPhongMaterial",{enumerable:!0,get:function(){return o.BlinnPhongMaterial}});var a=n(941);Object.defineProperty(t,"ShaderMaterial",{enumerable:!0,get:function(){return a.ShaderMaterial}});var s=n(331);Object.defineProperty(t,"UVMaterial",{enumerable:!0,get:function(){return s.UVMaterial}})},779:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OrthographicCamera=void 0;const r=n(717),i=n(534);class o extends i.Camera{constructor({left:e=-1,right:t=1,bottom:n=-1,top:i=1,near:o=.1,far:a=1e3,position:s=r.vec3.create(0,0,10),target:u=r.vec3.create(0,0,0),up:c=r.vec3.create(0,1,0)}={}){super(),this.left=e,this.right=t,this.bottom=n,this.top=i,this.near=o,this.far=a,this.position=r.vec3.clone(s),this.target=r.vec3.clone(u),this.up=r.vec3.clone(c)}updateProjectionMatrix(){console.log("Updating Orthographic Projection Matrix"),this._projectionMatrix=r.mat4.ortho(this.left,this.right,this.bottom,this.top,this.near,this.far),this._isProjectionDirty=!1}updateViewMatrix(){console.log("Updating Orthographic View Matrix"),this._viewMatrix=r.mat4.lookAt(this.position,this.target,this.up),this._isViewDirty=!1}setPosition(e,t,n){super.setPosition(e,t,n);const i=r.vec3.create(e,t,n);r.vec3.equals(this.position,i)||(this.position=r.vec3.copy(i,this.position),this._isViewDirty=!0)}setTarget(e){r.vec3.equals(this.target,e)||(this.target=r.vec3.copy(e,this.target),this._isViewDirty=!0)}setUp(e){r.vec3.equals(this.up,e)||(this.up=r.vec3.copy(e,this.up),this._isViewDirty=!0)}setLeft(e){this.left!==e&&(this.left=e,this._isProjectionDirty=!0)}setRight(e){this.right!==e&&(this.right=e,this._isProjectionDirty=!0)}setBottom(e){this.bottom!==e&&(this.bottom=e,this._isProjectionDirty=!0)}setTop(e){this.top!==e&&(this.top=e,this._isProjectionDirty=!0)}setNear(e){this.near!==e&&(this.near=e,this._isProjectionDirty=!0)}setFar(e){this.far!==e&&(this.far=e,this._isProjectionDirty=!0)}viewportResized(e){}}t.OrthographicCamera=o},819:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read_write> grid_mass_atomic: array<atomic<i32>>;\n@group(0) @binding(2) var<storage, read_write> grid_momentum_atomic: array<atomic<i32>>;\n@group(0) @binding(3) var<storage, read> particles_in: array<Particle>;\n@group(0) @binding(4) var<storage, read_write> particles_out: array<Particle>;\n\n@compute @workgroup_size(64) // Or your preferred workgroup size\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n    if (id.x >= params.num_particles) {\n        return;\n    }\n\n    let p = particles_in[id.x];\n\n    // 1. Calculate particle position in grid units and base cell for APIC stencil\n    let particle_pos_grid_units = p.position * params.inv_dx;\n    // cellIndex_base_int is the integer grid cell index for the center of the 3x3x3 stencil\n    let cellIndex_base_float = particle_pos_grid_units - 0.5;\n    let cellIndex_base_int = vec3<i32>(floor(cellIndex_base_float));\n    // cellDiff_from_base_center is particle's sub-grid pos relative to the center of cellIndex_base_int's cell\n    let cellDiff_from_base_center = cellIndex_base_float - vec3<f32>(cellIndex_base_int);\n\n    // 2. Calculate 1D B-spline weights for the 3 stencil nodes in each dimension\n    //    relative to cellIndex_base_int\n    var bspline_weights_1D: array<vec3<f32>, 3>; // [dim_idx][offset_idx from center: -1, 0, +1]\n    for (var d = 0u; d < 3u; d = d + 1u) {\n        let u_particle_offset = cellDiff_from_base_center[d];\n        bspline_weights_1D[d][0] = quadratic_bspline_N(u_particle_offset + 1.0); // Stencil offset -1\n        bspline_weights_1D[d][1] = quadratic_bspline_N(u_particle_offset);       // Stencil offset  0\n        bspline_weights_1D[d][2] = quadratic_bspline_N(u_particle_offset - 1.0); // Stencil offset +1\n    }\n\n    // 3. Iterate over 3x3x3 stencil\n    for (var gx_offset_idx = 0u; gx_offset_idx < 3u; gx_offset_idx = gx_offset_idx + 1u) {\n        for (var gy_offset_idx = 0u; gy_offset_idx < 3u; gy_offset_idx = gy_offset_idx + 1u) {\n            for (var gz_offset_idx = 0u; gz_offset_idx < 3u; gz_offset_idx = gz_offset_idx + 1u) {\n                \n                let final_weight = bspline_weights_1D[0][gx_offset_idx] *\n                                   bspline_weights_1D[1][gy_offset_idx] *\n                                   bspline_weights_1D[2][gz_offset_idx];\n\n                if (final_weight == 0.0) { continue; }\n\n                let target_grid_node_abs_idx = cellIndex_base_int +\n                                               vec3<i32>(i32(gx_offset_idx), i32(gy_offset_idx), i32(gz_offset_idx)) -\n                                               vec3<i32>(1, 1, 1);\n\n                // Boundary check for target_grid_node_abs_idx\n                if (target_grid_node_abs_idx.x < 0 || target_grid_node_abs_idx.x >= i32(params.grid_size) ||\n                    target_grid_node_abs_idx.y < 0 || target_grid_node_abs_idx.y >= i32(params.grid_size) ||\n                    target_grid_node_abs_idx.z < 0 || target_grid_node_abs_idx.z >= i32(params.grid_size)) {\n                    continue;\n                }\n                \n                let flat_target_idx = grid_idx_flat(target_grid_node_abs_idx, params.grid_size);\n                \n                // Calculate APIC momentum term contribution\n                // cellDist_world is vector from particle to current grid node's center (world units)\n                let grid_node_world_pos = (vec3<f32>(target_grid_node_abs_idx) + 0.5) * params.dx;\n                let cellDist_world = grid_node_world_pos - p.position;\n                let Q_affine_correction = p.affine_matrix_C * cellDist_world;\n\n                // Contributions\n                let mass_contrib = final_weight * p.mass;\n                let momentum_contrib_vec = final_weight * (p.mass * p.velocity + Q_affine_correction);\n\n                // Atomic adds\n                atomicAdd(&grid_mass_atomic[flat_target_idx], encodeFixedPoint(mass_contrib));\n                \n                let mom_x_idx = flat_target_idx * 3u + 0u;\n                let mom_y_idx = flat_target_idx * 3u + 1u;\n                let mom_z_idx = flat_target_idx * 3u + 2u;\n\n                atomicAdd(&grid_momentum_atomic[mom_x_idx], encodeFixedPoint(momentum_contrib_vec.x));\n                atomicAdd(&grid_momentum_atomic[mom_y_idx], encodeFixedPoint(momentum_contrib_vec.y));\n                atomicAdd(&grid_momentum_atomic[mom_z_idx], encodeFixedPoint(momentum_contrib_vec.z));\n            }\n        }\n    }\n\n    particles_out[id.x] = p;\n}\n"},838:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.BasicMaterial=void 0;const i=n(710),o=n(330),a=n(35),s=n(343),u=r(n(414)),c=r(n(43));class l extends a.Material{constructor(e,t={}){l.precompile(e),super(new s.UniformManager(e,{uniforms:[{name:"color",value:t.color||new i.Color(1,1,1)}],textures:[{texture:t.map||o.DefaultTexture.instance,dimension:"2d",accessType:"sample"}],label:"BasicMaterial"}))}get cacheKey(){return"basic-material"}get shaderCode(){return l.shaderModule}static precompile(e){l.shaderModule||(l.shaderModule=e.createShaderModule({label:"basic-material-shader",code:`\n${u.default}\n${c.default}\n`}))}}t.BasicMaterial=l,l.shaderModule=null},857:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.SphereGeometry=void 0;const r=n(80);function i(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]}function o(e){const t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return 0===t?[0,0,0]:[e[0]/t,e[1]/t,e[2]/t]}function a(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}class s extends r.Geometry{constructor(e,t={radius:.5,latitudeBands:32,longitudeBands:64,flatShading:!1}){const{radius:n,latitudeBands:r,longitudeBands:s,flatShading:u}=t,{vertices:c,indices:l,vertexCount:f,indexCount:d,arrayStride:h}=function(e=.5,t=32,n=64,r=!1){const s=[],u=[];if(r){let r=0;for(let c=0;c<t;c++)for(let l=0;l<n;l++){const f=[];for(let r=0;r<2;r++){const i=c+r,o=i*Math.PI/t,a=Math.sin(o),s=Math.cos(o);for(let r=0;r<2;r++){const o=l+r,u=2*o*Math.PI/n,c=Math.sin(u),d=Math.cos(u)*a,h=s,_=c*a,m=1-o/n,p=1-i/t;f.push({pos:[e*d,e*h,e*_],uv:[m,p]})}}const d=f[0],h=f[1],_=f[2],m=f[3],p=d.pos,g=_.pos,v=h.pos,y=d.uv,b=_.uv,x=h.uv;let M=a(g,p),w=a(v,p),S=o(i(M,w));s.push(...p,...y,...S),s.push(...g,...b,...S),s.push(...v,...x,...S),u.push(r++,r++,r++);const P=h.pos,B=_.pos,U=m.pos,T=h.uv,D=_.uv,A=m.uv;M=a(B,P),w=a(U,P);let C=o(i(M,w));s.push(...P,...T,...C),s.push(...B,...D,...C),s.push(...U,...A,...C),u.push(r++,r++,r++)}}else{for(let r=0;r<=t;r++){const i=r*Math.PI/t,o=Math.sin(i),a=Math.cos(i);for(let i=0;i<=n;i++){const u=2*i*Math.PI/n,c=Math.sin(u),l=Math.cos(u)*o,f=a,d=c*o,h=1-i/n,_=1-r/t;s.push(e*l,e*f,e*d),s.push(h,_),s.push(l,f,d)}}for(let e=0;e<t;e++)for(let t=0;t<n;t++){const r=e*(n+1)+t,i=r+n+1;u.push(r,i,r+1),u.push(i,i+1,r+1)}}const c=new Float32Array(s),l=new Uint16Array(u),f=l.length;return{vertices:c,indices:l,vertexCount:r?f:(t+1)*(n+1),indexCount:f,arrayStride:32,floatsPerVertex:8}}(n,r,s,u),_=e.createBuffer(c,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),m=e.createBuffer(l,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST);super(e,_,m,d,f),this._arrayStride=h,this._radius=n,this._latitudeBands=r,this._longitudeBands=s,this._flatShading=u}get cacheKey(){return`SphereGeometry_r${this._radius}_lat${this._latitudeBands}_lon${this._longitudeBands}_flat${this._flatShading}`}get bufferLayout(){return[{arrayStride:this._arrayStride,attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x2"},{shaderLocation:2,offset:20,format:"float32x3"}]}]}}t.SphereGeometry=s},861:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read> grid_velocity_in: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read> particles_in: array<Particle>;\n@group(0) @binding(3) var<storage, read_write> particles_out: array<Particle>;\n\n//--------------------------------------------------------------------------------------\n// Main Compute Shader\n//--------------------------------------------------------------------------------------\n@compute @workgroup_size(64, 1, 1) // Example workgroup size\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\n    if (id.x >= params.num_particles) {\n        return;\n    }\n\n    let p_in = particles_in[id.x];\n    var p_out = p_in; // Initialize output particle with input values\n\n    // 1. Calculate particle position in grid units and base cell for APIC stencil\n    let particle_pos_grid_units = p_in.position * params.inv_dx;\n    // cellIndex_base_int is the integer grid cell index for the center of the 3x3x3 stencil\n    let cellIndex_base_float = particle_pos_grid_units - 0.5;\n    let cellIndex_base_int = vec3<i32>(floor(cellIndex_base_float));\n    // cellDiff_from_base_center is particle's sub-grid pos relative to the center of cellIndex_base_int's cell\n    let cellDiff_from_base_center = cellIndex_base_float - vec3<f32>(cellIndex_base_int);\n\n    // 2. Calculate 1D B-spline weights (same as in P2G)\n    var bspline_weights_1D: array<vec3<f32>, 3>; // [dim_idx][offset_idx from center: -1, 0, +1]\n    for (var d = 0u; d < 3u; d = d + 1u) {\n        let u_particle_offset = cellDiff_from_base_center[d];\n        bspline_weights_1D[d][0] = quadratic_bspline_N(u_particle_offset + 1.0); // Stencil offset -1\n        bspline_weights_1D[d][1] = quadratic_bspline_N(u_particle_offset);       // Stencil offset  0\n        bspline_weights_1D[d][2] = quadratic_bspline_N(u_particle_offset - 1.0); // Stencil offset +1\n    }\n\n    var new_particle_velocity = vec3<f32>(0.0, 0.0, 0.0);\n    var new_particle_C = mat3x3<f32>(); // Zero matrix\n\n    // 3. Iterate over 3x3x3 stencil to interpolate velocity and C matrix\n    for (var gx_offset_idx = 0u; gx_offset_idx < 3u; gx_offset_idx = gx_offset_idx + 1u) {\n        for (var gy_offset_idx = 0u; gy_offset_idx < 3u; gy_offset_idx = gy_offset_idx + 1u) {\n            for (var gz_offset_idx = 0u; gz_offset_idx < 3u; gz_offset_idx = gz_offset_idx + 1u) {\n                \n                let final_weight = bspline_weights_1D[0][gx_offset_idx] *\n                                   bspline_weights_1D[1][gy_offset_idx] *\n                                   bspline_weights_1D[2][gz_offset_idx];\n\n                if (final_weight == 0.0) { continue; }\n\n                let target_grid_node_abs_idx = cellIndex_base_int +\n                                               vec3<i32>(i32(gx_offset_idx), i32(gy_offset_idx), i32(gz_offset_idx)) -\n                                               vec3<i32>(1, 1, 1); // Absolute grid indices\n\n                // For G2P, we read from grid. Boundary handling for reads is often done by clamping\n                // indices in the grid_idx_flat function or ensuring particles don't get too close.\n                // The grid_idx_flat above includes clamping.\n                let flat_target_idx = grid_idx_flat_clamp(target_grid_node_abs_idx, params.grid_size);\n                let grid_node_vel = grid_velocity_in[flat_target_idx];\n\n                // Interpolate particle velocity\n                new_particle_velocity = new_particle_velocity + final_weight * grid_node_vel;\n\n                // Interpolate C matrix (APIC)\n                // dist_grid_node_to_particle_world is vector from grid node center to particle (world units)\n                let grid_node_world_pos = (vec3<f32>(target_grid_node_abs_idx) + 0.5) * params.dx;\n                let dist_grid_node_to_particle_world = p_in.position - grid_node_world_pos;\n                \n                // Original MLS-MPM/APIC C update: C += 4 * inv_dx^2 * weight * vel_grid * (pos_grid - pos_particle)_world\n                // The factor inv_dx^2 is often because C itself represents dv/dx, and dpos is dx.\n                // Python: new_C += 4 * inv_dx * weight * g_v.outer_product(dpos) where dpos is (offset_float - fx_norm)\n                // (offset_float - fx_norm) is like (grid_node_rel_to_base - particle_pos_rel_to_base)\n                // = (grid_node_abs - particle_pos_abs) in grid units\n                // So dpos_grid_units = vec3<f32>(target_grid_node_abs_idx) - particle_pos_grid_units\n                let dpos_grid_units = vec3<f32>(target_grid_node_abs_idx) - particle_pos_grid_units;\n\n                let term_outer_product = calculate_outer_product(grid_node_vel, dpos_grid_units);\n                new_particle_C = new_particle_C + ( (4.0 * params.inv_dx) * final_weight) * term_outer_product;\n            }\n        }\n    }\n\n    // 4. Update particle state\n    p_out.velocity = new_particle_velocity;\n    p_out.affine_matrix_C = new_particle_C;\n\n    // Update Jf (elastic volume determinant) - as in mls_mpm.py G2P\n    // Jf[p] *= 1 + dt * new_C.trace()\n    let trace_C = new_particle_C[0][0] + new_particle_C[1][1] + new_particle_C[2][2];\n    p_out.Jf = p_in.Jf * (1.0 + params.dt * trace_C);\n\n    // Advect particle position (using new velocity)\n    p_out.position = p_in.position + new_particle_velocity * params.dt;\n    \n    // F and Jp were updated in P2G. Mass and material_idx are unchanged.\n    particles_out[id.x] = p_out;\n}\n\nfn calculate_outer_product(a: vec3<f32>, b: vec3<f32>) -> mat3x3<f32> {\n    let col0 = a * b.x;\n    let col1 = a * b.y;\n    let col2 = a * b.z;\n    return mat3x3<f32>(col0, col1, col2);\n}\n"},898:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeTask=void 0;const r=n(717),i=n(343);t.ComputeTask=class{constructor(e,t){this._options=t,this._uniformManager=new i.UniformManager(e,{uniformVisibility:GPUShaderStage.COMPUTE,buffers:this._options.buffers,textures:this._options.textures,samplers:this._options.samplers,compute:!0})}get cacheKey(){return`ComputeTask:${this.label}:${this._uniformManager.cacheKey}`}get shaderModule(){return this._options.shader}get label(){return this._options.label||"Compute Task"}get dispatchCount(){return this._options.dispatchCount||r.vec3.create(8,8,1)}get bindGroupLayout(){return this._uniformManager.bindGroupLayout}get bindGroup(){return this._uniformManager.bindGroup}get entryPoint(){return this._options.entryPoint}}},941:function(e,t,n){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.ShaderMaterial=void 0;const i=n(35),o=n(343),a=r(n(414));class s extends i.Material{constructor(e,t){super(new o.UniformManager(e,{uniforms:t.uniforms,textures:t.textures,buffers:t.buffers,label:"ShaderMaterial"})),this._options=t,this.compile(e)}compile(e){this._shaderModule=e.createShaderModule({label:"ShaderModule",code:`\n${a.default}\n${this._options.code}\n      `})}get cacheKey(){return this._uniformManager.cacheKey+"-"+btoa(this._options.code)}get shaderCode(){return this._shaderModule}}t.ShaderMaterial=s},950:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r="//--------------------------------------------------------------------------------------\n// Bindings\n//--------------------------------------------------------------------------------------\n@group(0) @binding(0) var<uniform> params: SimParams;\n@group(0) @binding(1) var<storage, read_write> grid_mass_in: array<atomic<i32>>;     // Read the atomically summed mass\n@group(0) @binding(2) var<storage, read_write> grid_momentum_in: array<atomic<i32>>; // Read the atomically summed momentum (flat)\n@group(0) @binding(3) var<storage, read_write> grid_velocity_out: array<vec3<f32>>; // Write final f32 velocities\n\n//--------------------------------------------------------------------------------------\n// Main Compute Shader\n//--------------------------------------------------------------------------------------\n@compute @workgroup_size(4, 4, 4) // Example 3D workgroup size, total 512. Adjust as needed.\n                                 // Dispatch would be ceil(grid_size/8) in each dimension.\nfn main(@builtin(global_invocation_id) grid_coords_abs_u32: vec3<u32>) {\n    // grid_coords_abs_u32 are the absolute 3D integer coordinates of the current grid cell\n\n    if (grid_coords_abs_u32.x >= params.grid_size ||\n        grid_coords_abs_u32.y >= params.grid_size ||\n        grid_coords_abs_u32.z >= params.grid_size) {\n        return; // Out of bounds for the grid\n    }\n\n    // Convert 3D grid coords to 1D flat index for accessing input buffers\n    let flat_idx = grid_coords_abs_u32.x * params.grid_size * params.grid_size +\n                   grid_coords_abs_u32.y * params.grid_size +\n                   grid_coords_abs_u32.z;\n\n    if (flat_idx == 0u) { // Test for the first grid cell\n        let test_float: f32 = 1.23;\n        let encoded_test: i32 = encodeFixedPoint(test_float); // Uses FIXED_POINT_MULTIPLIER from structs.wgsl\n        let decoded_test: f32 = decodeFixedPoint(encoded_test);\n        grid_velocity_out[flat_idx] = vec3<f32>(f32(encoded_test), decoded_test, test_float);\n        return; // Only process this one cell for this test\n    }\n\n    // 1. Decode mass\n    // atomicLoad is not strictly necessary if Stage 1 P2G is guaranteed to finish before this.\n    // We can treat them as regular i32 after the P2G pass.\n    // For clarity of intent (that these were atomically written):\n    let mass_fixedpoint = atomicLoad(&grid_mass_in[flat_idx]);\n    let mass_float = 1.0; //decodeFixedPoint(mass_fixedpoint);\n\n    var final_velocity = vec3<f32>(0.0, 0.0, 0.0);\n\n    if (mass_float > 1e-9) { // Or some other small epsilon to avoid division by zero\n        // 2. Decode momentum\n        let mom_x_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 0u]);\n        let mom_y_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 1u]);\n        let mom_z_fixedpoint = atomicLoad(&grid_momentum_in[flat_idx * DIMENSIONS + 2u]);\n\n        var momentum_float = vec3<f32>(\n            decodeFixedPoint(mom_x_fixedpoint),\n            decodeFixedPoint(mom_y_fixedpoint),\n            decodeFixedPoint(mom_z_fixedpoint)\n        );\n\n        // 3. Normalize to get velocity\n        final_velocity = momentum_float / mass_float;\n\n        // final_velocity.y = final_velocity.y - 9.8 * 0.0001;\n\n        // 4. Apply Gravity\n        final_velocity.y = final_velocity.y - params.gravity * params.dt;\n\n        // 5. Apply Boundary Conditions\n        // Using grid_coords_abs_u32 (which are 0 to grid_size-1)\n        let boundary_min = f32(params.boundary_extent);\n        let boundary_max = f32(params.grid_size) - f32(params.boundary_extent) -1.0; // -1 because grid_coords are 0-indexed\n\n        // X-axis boundaries\n        // if (f32(grid_coords_abs_u32.x) < boundary_min && final_velocity.x < 0.0) {\n        //     final_velocity.x = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.x) > boundary_max && final_velocity.x > 0.0) {\n        //     final_velocity.x = 0.0;\n        // }\n\n        // // Y-axis boundaries\n        // if (f32(grid_coords_abs_u32.y) < boundary_min && final_velocity.y < 0.0) {\n        //     final_velocity.y = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.y) > boundary_max && final_velocity.y > 0.0) {\n        //     // Example: Sticky top boundary or just reflect/zero\n        //     final_velocity.y = 0.0;\n        // }\n\n        // // Z-axis boundaries\n        // if (f32(grid_coords_abs_u32.z) < boundary_min && final_velocity.z < 0.0) {\n        //     final_velocity.z = 0.0;\n        // }\n        // if (f32(grid_coords_abs_u32.z) > boundary_max && final_velocity.z > 0.0) {\n        //     final_velocity.z = 0.0;\n        // }\n    }\n    // Else (mass is zero), final_velocity remains (0,0,0)\n\n    // 6. Write to output velocity buffer\n    grid_velocity_out[flat_idx] = final_velocity;\n}"},997:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.LightManager=void 0;const r=n(249),i=n(435);t.LightManager=class{constructor(e){this._lights=new Set,this._maxLights=100,this._dirty=!0,this._lights.clear(),this._renderer=e}set lights(e){for(const t of e)this._lights.has(t)||(this._lights.add(t),this._dirty=!0)}get lightsArray(){return this._dirty&&(this.packLights(),this._dirty=!1),this._lightsArr}get numLights(){return this._lights.size}get buffer(){return this._dirty&&(this.packLights(),this._dirty=!1),this._buffer}addLight(e){this._lights.has(e)||(this._lights.add(e),this._dirty=!0)}clean(){this._dirty&&(this.packLights(),this._dirty=!1)}createLightsBuffer(){const e=(new i.Light).encode(),t=(0,r.packUniforms)([e]);if(e.type!==i.SHADER_LIGHT_STRUCT_TYPE_NAME)throw new Error(`LightManager Init Error: Template light 'type' (${e.type}) must be '${i.SHADER_LIGHT_STRUCT_TYPE_NAME}'.`);if(e.members!==i.SHADER_LIGHT_MEMBERS_LAYOUT)throw new Error("LightManager Init Error: Template light 'members' must be the shared SHADER_LIGHT_MEMBERS_LAYOUT export.");const n=new Uint8Array(t);this._structLen=n.byteLength;const o=this._structLen*this._maxLights;this._lightsBuffer=new ArrayBuffer(o),this._lightsArr=new Uint8Array(this._lightsBuffer),this._buffer=this._renderer.createBuffer(this._lightsArr,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}packLights(){this._lightsBuffer||this.createLightsBuffer();let e=0;for(const t of this._lights){if(e>=this._maxLights){console.warn("LightManager: Exceeded maxLights while packing. Some lights will be omitted.");break}const n=this._structLen*e,i=t.encode(),o=(0,r.packUniforms)([i]);this._lightsArr.set(new Uint8Array(o),n),e++}this._renderer.device.queue.writeBuffer(this._buffer,0,this._lightsBuffer,0)}}}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(325)})()));